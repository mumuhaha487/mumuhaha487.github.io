<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 木哈文轩</title>
    <link>https://0ha.top/posts/</link>
    <description>Recent content in Posts on 木哈文轩</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 29 Feb 2024 13:54:19 +0000</lastBuildDate>
    <atom:link href="https://0ha.top/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>利用python爬取本站的所有博客链接</title>
      <link>https://0ha.top/posts/136375650/</link>
      <pubDate>Thu, 29 Feb 2024 13:54:19 +0000</pubDate>
      <guid>https://0ha.top/posts/136375650/</guid>
      <description>目录&#xA;前因&#xA;首先的尝试&#xA;解决办法&#xA;导入包&#xA;定义一个json配置文件&#xA;打开浏览器执行操作&#xA;注意&#xA;提取源代码并且进行筛选链接&#xA;执行结果&#xA;前因 由于自己要把csdn的博客同步到hugo中，把博客转为md格式已经搞好了，但是由于csdn的图片具有防盗链，所以打算把所有的图片爬取下来，然后保存在本地&#xA;刚好本人略懂一些python，所以自己先写了一个脚本用来爬取各个博客的链接，如果不想听我多bb的直接去我的github看源码&#xA;GitHub - mumuhaha487/Get_csdn Contribute to mumuhaha487/Get_csdn development by creating an account on GitHub.https://github.com/mumuhaha487/Get_csdn ;&#xA;首先的尝试 首先的尝试就是利用简单好用的request包进行爬取。&#xA;但是由于csdn的博客是不显示全部，滑动底部时更新一部分&#xA;request包可能做不了这么复杂的工作QAQ&#xA;好像https://blog.csdn.net/你的名字/article/list/链接可以用request包进行爬取&#xA;解决办法 那么恰好我有学过一点点的selenium包，所以搞了一个自动化的形式通过模拟鼠标滑动到文章的底部来获取到所有的文章链接&#xA;导入包 各个包都有解释用途&#xA;from selenium import webdriver from selenium.webdriver.common.keys import Keys from selenium.webdriver.common.action_chains import ActionChains #用于自动化框架执行动作 import time #延时操作，方便网站加载完全 import json #用于读取配置信息 import re #从源代码中提取文章的链接 定义一个json配置文件 定义一个json配置文件方便管理&#xA;现在文件只有用户名称,后续可加配置&#xA;{ &amp;#34;blog_id&amp;#34;: &amp;#34;mumuemhaha&amp;#34; } 读取用户名称，并且将其拼接成csdn个人博客链接&#xA;with open(&amp;#34;./config.json&amp;#34;,&amp;#39;r&amp;#39;) as file_1: data_1=json.</description>
    </item>
    <item>
      <title>sillyGirl（傻妞机器人）安装以及对接go-cqhttp（2023年12月）</title>
      <link>https://0ha.top/posts/134980875/</link>
      <pubDate>Wed, 28 Feb 2024 15:20:00 +0000</pubDate>
      <guid>https://0ha.top/posts/134980875/</guid>
      <description>目录&#xA;编写的原因&#xA;下载傻妞&#xA;注意！！注意！！！注意！！！！&#xA;同样的下载go-cqhttp&#xA;安装以及配置 go-cqhttp&#xA;下载screen&#xA;创建go-cqhttp窗口&#xA;创建sillyGirl窗口&#xA;常见错误&#xA;编写的原因 暑假的时候安装教程安装过傻妞机器人，但是最近安装的时候发现出了问题，结果一看傻妞的版本好像更新了而且对接QQ的方法不一样了，一看csdn没有教程，那我就自己摸索终于搞出来了&#xA;下载傻妞 废话不多说&#xA;首先创建一个文件夹名字随意，创建的文件夹名称是sillyGirl&#xA;mkdir /root/sillyGirl 然后下载傻妞的源文件，由于github半墙，下载困难，我这里直接给出分享连接了，可以的话还是去github上下载支持作者，但是好像作者的博客删了QAQ&#xA;傻妞下载链接&#xA;注意一下， 给出的下载链接的配置环境为x86_64架构的linux系统，如果其他的系统环境要另外的去下载，由于wget不支持断点续传（maybe）所以建议在自己的windows上下载好然后传给linux的/root/sillyGirl上面（如果你创建了文件夹的话）。&#xA;之后进入文件夹&#xA;cd /root/sillyGirl 给予权限并且运行可执行文件&#xA;chmod 777 sillyGirl ./sillyGirl 之后进入网页后台&#xA;http://你linux服务器端的ip:8080&#xA;注意！！注意！！！注意！！！！ 傻妞机器人更新之后不支持OnebotV11协议标准机器人的反向wesocket的方式接入&#xA;需要在插件商城中下载&#xA;搜索 OnebotV11(原内置QQ)&#xA;或者直接搜索QQ也行&#xA;下载好后才可以进行对接&#xA;同样的下载go-cqhttp 也是一样的方法——在windows下的github上下载文件然后传到linux上面&#xA;go-cqhttp下载链接&#xA;里面有如下文件&#xA;顺便教大家看看github下如何安装你操作系统适配的安装包&#xA;安装以及配置 go-cqhttp 处理器和操作系统是什么型号就下载什么型号（或者下载tar.gz然后解压进入文件夹运行也行，这个目前不展开说），我的是ubuntu系统进入安装包的目录直接安装就行&#xA;dpkg -i 安装包名称 这样就安装好了然后运行&#xA;go-cqhttp 会出现这样的截图&#xA;选择3——反向 Websocket 通信&#xA;然后按回车放回之后进入配置文件&#xA;nano config.yml 我的建议是扫码登录修改这个参数&#xA;修改这个这个为你的代理服务器&#xA;ws://127.0.0.1:8080/bot/onebotv11 这里的8080端口为你的傻妞机器人的默认端口，如果换了端口记得把这个8080换了&#xA;下载screen 由于运行傻妞机器人和go-cqhttp的时候会独占整个窗口并且当ssh退出时（不是用ssh链接而是用vnc桌面连接的随意QAQ），任务也会停止。所以要用screen相当于后台新开一个屏幕运行这两个程序。&#xA;我用的是ubuntu/debian不同操作系统之间的安装命令可能会不一样（可以百度一下）&#xA;apt-get install screen 然后接下来就是screen的命令</description>
    </item>
    <item>
      <title>Wordpress博客在做内网穿透时候输入网址后面会带端口号的解决办法</title>
      <link>https://0ha.top/posts/131609600/</link>
      <pubDate>Wed, 28 Feb 2024 12:53:10 +0000</pubDate>
      <guid>https://0ha.top/posts/131609600/</guid>
      <description>在我输入域名是会跳转到我在内网映射的端口，这时候就要忽略端口号&#xA;解决办法&#xA;在网站的目录下的wp-config.php文件下末尾输入下面的内容&#xA;define(&amp;#39;WP_SITEURL&amp;#39;, &amp;#39;http://&amp;#39; . $_SERVER[&amp;#39;HTTP_HOST&amp;#39;]); define(&amp;#39;WP_HOME&amp;#39;, &amp;#39;http://&amp;#39; . $_SERVER[&amp;#39;HTTP_HOST&amp;#39;]); </description>
    </item>
    <item>
      <title>用python从零开始做一个最简单的小说爬虫带GUI界面（3/3）</title>
      <link>https://0ha.top/posts/132471796/</link>
      <pubDate>Wed, 28 Feb 2024 09:07:46 +0000</pubDate>
      <guid>https://0ha.top/posts/132471796/</guid>
      <description>目录&#xA;上一章内容&#xA;前言&#xA;出现的一些问题&#xA;requests包爬取小说的不便之处&#xA;利用aiohttp包来异步爬取小说&#xA;介绍&#xA;代码&#xA;main.py&#xA;test_1.py&#xA;test_3.py&#xA;代码大致讲解&#xA;注意&#xA;系列总结&#xA;上一章内容 用python从零开始做一个最简单的小说爬虫带GUI界面（2/3）_木木em哈哈的博客-CSDN博客前一章博客我们讲了怎么通过PyQt5来制作图形化界面，并且进行一些基本设置接下来两章我们主要讲核心爬虫代码的实现。https://blog.csdn.net/mumuemhaha/article/details/132457770?spm=1001.2014.3001.5501 ;&#xA;前言 本章内容讲的是给出了小说文章链接的情况下，如何爬取小说&#xA;出现的一些问题 requests包爬取小说的不便之处 在最开始的时候包括我前段时间写的博客都是利用requests包进行爬取&#xA;但是这回出现一个问题&#xA;简单来说就是request是顺序执行的&#xA;必须要等到上一个网络的请求返回后才会执行下一个步骤&#xA;假设我要爬取的小说有2000个章节&#xA;每次返回请求并且处理信息都需要1秒的时间&#xA;那么总共就需要2000秒也就是半个多小时&#xA;要是中间再来个返回超时出现错误的&#xA;心态直接要爆炸&#xA;返回超时我们可以设置超时等待时间&#xA;但是占据大部分时间的依然是网络请求的延迟&#xA;那有什么方法可以解决呢&#xA;利用aiohttp包来异步爬取小说 介绍 异步是一种比多线程高效得多的并发模型，是无序的，为了完成某个任务，在执行的过程中，不同程序单元之间过程中无需通信协调，也能完成任务的方式，也就是说不相关的程序单元之间可以是异步的。&#xA;简单来说就是可以类比小学的一种数学——你可以再烧开水的时候洗菜，在煮饭的时候切菜的那类问题&#xA;在python程序中就是你在等待网络回复的数据包时候可以继续发送其他的数据包&#xA;起到资源利用趋于最大化的趋势&#xA;代码 具体的代码在这&#xA;这里只做初步介绍，具体包的使用不展开细讲&#xA;main.py import sys # PyQt5中使用的基本控件都在PyQt5.QtWidgets模块中 from PyQt5.QtWidgets import QApplication, QMainWindow # 导入designer工具生成的login模块 from win import Ui_MainWindow from test_1 import * from test_3 import * import time class MyMainForm(QMainWindow, Ui_MainWindow): def __init__(self, parent=None): super(MyMainForm, self).</description>
    </item>
    <item>
      <title>关于我组件家庭服务器，挑选硬件设备的经历</title>
      <link>https://0ha.top/posts/131825238/</link>
      <pubDate>Tue, 27 Feb 2024 22:19:31 +0000</pubDate>
      <guid>https://0ha.top/posts/131825238/</guid>
      <description>目录&#xA;起因&#xA;升级——玩客云&#xA;原因&#xA;折腾日记&#xA;又升级——d2550工控主机&#xA;原因&#xA;折腾日记&#xA;又双升级——itx主机&#xA;原因&#xA;折腾日记&#xA;又双叒升级（目前再用的机器）——i9级x99平台e5v3主机&#xA;原因&#xA;折腾日记&#xA;心得&#xA;起因 起因大概在今年三月底四月初的时候，b站上刷到许多随身wifi的视频（没错就是那个9.9包邮有时候还可以叠优惠卷实现白嫖的那个东西）&#xA;大概呢。。。这个样子&#xA;小小的十分卡哇伊&#xA;由于随身wifi内用的是一些arm架构的处理器&#xA;其中如果是晓龙cpu的话，还可以刷一个精简的linux系统，csdn上和b站上有手把手的教学&#xA;然后当时我把他插在充电器那里，挂青龙面板去跑任务薅京东的羊毛&#xA;其实虽然这也不是第一次接触linux系统，但是纯命令行的操作让我还是感觉不习惯&#xA;升级——玩客云 原因 用了一个月之后我发现有个宝塔面板的东西好像可以用来搭建网站，但是当我下载好后宝塔面板时空间已经所剩60M了，毕竟随身wifi大部分都只有（512MB运行内存+4G存储空间），完全不够用，而且打开宝塔面板时会发现难以忍受的加载速度十分慢&#xA;这个时候我萌生出了升级设备的念头&#xA;在咸鱼上一看明确是1+8G的要四五十块钱，好贵！&#xA;然后我发现了一个颜值比较高，而且价格不贵的东西&#xA;折腾日记 玩客云，本来是迅雷公司用来挖矿的矿机，但是现在降到了30多元一台&#xA;搭载的的是s805的处理器（32位的cpu，注意！！后面会再次提到的）&#xA;自带两个usb2.0的口可以千兆网口（虽然这cpu也肯定跑不满）&#xA;同时有1G的运行内存和8G的存储空间&#xA;东西到手之后，同样也刷了linux的系统，安装docker发现也比以前快的多&#xA;但是问题随之而来——因为处理器是32位的，所以安装不少软件会不兼容然后报错（就比如宝塔面板只能安装5.9版本的）&#xA;后面还是通过一系列b站大佬的一些骚操作也安装到了7.x版本的玩客云&#xA;又升级——d2550工控主机 原因 玩客云虽然性能够用，但是还是有挺多地方用的不舒服的（比如usb2.0的口，cpu性能跑不满千兆，8G存储虽然很多但是还是不够用之类的）&#xA;我就在想，为什么我不直接搞一台x86的主机呢？&#xA;在b站下面的评论中我看到了一个设备&#xA;d2550主机性能吊打前面的两个处理器&#xA;大小虽然大了一点点但是还是可以接受&#xA;折腾日记 emm，没啥好说的&#xA;本来听说有一些d2550的主机搭载的是32位bios，即使是64位的cpu依旧安装不了64位的系统&#xA;还好我到货了发现的64位的bios&#xA;接下来就很好办了（不得不说，linux第一次用的这么舒服）&#xA;接口方面也给出了一个usb3.0的接口方便拓展&#xA;到现在，我觉得当一个轻量的网站服务器就没什么问题了&#xA;又双升级——itx主机 原因 性能够用,但是要折腾其他的东西性能不够用&#xA;在cpu114中显示我的d2550跑分500+分&#xA;但是我在咸鱼上看到一个itx主机，发现这大小可以放在寝室而且性能搭载的是i3-4170&#xA;cpu114上显示的是快4000的跑分&#xA;于是我把原来的主机卖了后买来了一个这个（图片没有了，大概是23cm23cm7cm的亚克力板的主机）&#xA;折腾日记 到手后我安装好linux后折腾了许多东西，什么网站服务器，视频播放器，私人云盘，许多的docker项目，我的许多四月底之后的博客大部分都是这么来的&#xA;现在的性能都不是够用了，而是有些溢出了，而且有pcie插槽，后续可以换e3v3&#xA;还可以安装win10，他是目前在我手上活的最久的一台机器&#xA;又双叒升级（目前再用的机器）——i9级x99平台e5v3主机 原因 之前看cpu的时候发现了e5这一款香到爆炸的cpu——价格低，核心多，虽然单核性能不高，但是对我服务器的影响真不大，多核性能力压群雄，仅需某宝售价7块钱的cpu，多核性能直接乱杀&#xA;放一张cpu114的图（不准确，但是确实直观感受他的强悍，可以用于参考参考）&#xA;当然x99平台电费高，cpu发热大，主板贵都是他的缺点&#xA;我的配置就是x99+e5-2676 v3（12核24线程，耗费60大洋）+便宜大碗的32G服务器内存&#xA;折腾日记 这会我一改以前祖传的debian系统，给主机安装了一个pve（Proxmox Virtual Environment）虚拟机（其实还是基于debian系统的）</description>
    </item>
    <item>
      <title>python库的etree函数转换源代码时只有一行代码</title>
      <link>https://0ha.top/posts/131117661/</link>
      <pubDate>Tue, 27 Feb 2024 16:26:02 +0000</pubDate>
      <guid>https://0ha.top/posts/131117661/</guid>
      <description>解决办法&#xA;附上代码&#xA;from lxml import etree text = &amp;#39;&amp;#39;&amp;#39; first item second item third item fourth item &amp;#39;&amp;#39;&amp;#39; html_1 = etree.HTML(text) print(type(html_1)) print(html_1) 打印出来的结果就是&#xA;原因也十分简单，因为etree函数需要传递的编码格式为&amp;rsquo;utf-8&#39;&#xA;而python中变量的编码格式为Unicode格式&#xA;格式不同，传递的时候当然会出错&#xA;可以用bs4库中的BeautifulSoup，但是etree基于c语言编写运行的速度一般来说比前者要快&#xA;所以我铁了心了要用它有什么办法吗？&#xA;解决办法 有！！！&#xA;既然要utf-8，那我就把编码格式转成utf-8不就行了&#xA;怎么转呢？&#xA;只需要把Unicode的字符转为bytes类型&#xA;然后用decode(&amp;lsquo;utf-8&amp;rsquo;)函数来解码为utf-8&#xA;代码附上&#xA;bytes_res = etree.tostring(html_1) str_res = etree.tostring(html_1).decode(&amp;#39;utf-8&amp;#39;) print(str_res) 打印出来的结果就是&#xA;first item&#xA;second item&#xA;third item&#xA;fourth item&#xA;fifth item&#xA;这样就打印好了&#xA;因为为utf-8格式所以在输入中文是打印出来的也不是中文，而是一个诸如&amp;quot;啊&amp;quot;的英文代码 但是问题不大，只要中文不是乱码就应该还能识别回来</description>
    </item>
    <item>
      <title>pve安装ikuai并设置，同时把pve的网络连接到ikuai虚拟机</title>
      <link>https://0ha.top/posts/131976028/</link>
      <pubDate>Tue, 27 Feb 2024 11:53:11 +0000</pubDate>
      <guid>https://0ha.top/posts/131976028/</guid>
      <description>目录&#xA;前因&#xA;前置条件&#xA;安装ikuai&#xA;进入ikuai的后台&#xA;配置lan口，以及wan口&#xA;配置lan口桥接&#xA;按实际情况来设置了&#xA;单拨（PPOE拨号）&#xA;多拨(内外网设置点击基于物理网卡的混合模式)&#xA;后续步骤&#xA;pve连接虚拟机ikuai的网络以及其他虚拟机连接ikuai的网络&#xA;前因 pve安装好后，如果你有不止一个网口（单网口也行，不过要特殊的交换机来做单臂路由器，如果有多余的pcie口的话建议还是拓展出网口）&#xA;前置条件 接下来进入pve的webui中进行添加虚拟网卡（一般pve只会虚拟出一张虚拟网卡，我们要进行替换）&#xA;填上网卡的名称就行了&#xA;不知道的可以用&#xA;ip a 查看，其中真实的物理网卡一般是enp开头的名称，别搞错了（算了还是上张图吧！！）&#xA;设置好了点击确定然后应用配置（好像会报一个什么命令找不到错误，但是创建出来的网口可以用，所以问题不大）&#xA;安装ikuai 多余的也不多说（上传镜像-&amp;gt;创建虚拟机-&amp;gt;操作系统中选择ikuai的镜像-&amp;gt;分配好内存cpu-&amp;gt;开机安装）&#xA;之后安装ikuai就是正常的安装其他系统一样，安装过了不上图了（别跟我提这个你也不会操作，接下来安装系统也就两步——选择安装硬盘-&amp;gt;yes）&#xA;进入ikuai的后台 我改了后台地址默认是192.168.1.1&#xA;如果要改的话选择2改你的lan口网络地址&#xA;改为192.168.2.1/255.255.255.0(192.168.2.1可以随便变，这就是你的后台地址&#xA;接下就是修改你的ip地址改成与他同一网段右键wifi&#xA;ip地址改为同一网段就行&#xA;比如后台是192.168.2.1你就改成192.168.2.2&#xA;子网掩码改为255.255.255.0就可以了&#xA;接下来输入光猫的后台地址就可以进入ikuai控制台&#xA;账号是admin&#xA;默认密码是admin或者是（adminadmin）&#xA;或者这样也可以查看&#xA;配置lan口，以及wan口 简单来说WAN口就是连接外网的接口，LAN口就是连接局域网/内网的接口&#xA;开始lan口就是你创建系统时你选择的网口（为了可以直接访问ikuai后台）&#xA;此时我们要添加新的网口，来做wan口（lan/wan口设置不做考虑，太麻烦了）&#xA;有多少个网口添加上去就可以了&#xA;配置lan口桥接 点击lan1&#xA;点击高级设置把其他的网口全部连接起来（最好把ip地址也改一下，之前的192.168.1.1会和光猫的ip后台冲突）&#xA;按实际情况来设置了 如果你是连接到上级路由器或者是拨号光猫的话&#xA;点击wan口设置&#xA;直接选择dhcp（动态获取ip）就行了&#xA;如果连接的是桥接光猫&#xA;下面两个都可以选择（前提是你知道你的宽带账号和密码）&#xA;第一个是单拨（就是一个宽带账号拨号一次），第二个就是多拨（一个宽带账号或者是多个宽带账号拨多次，实现宽带叠加（叠加速率上限看光猫的网口速率/拨号成不成功看当地运营商支不支持多拨））&#xA;单拨（PPOE拨号） 很简单，前提是你知道你的宽带账号和密码&#xA;设置这个就可以了&#xA;多拨(内外网设置点击基于物理网卡的混合模式) 前置设置（按照这个来就行了）&#xA;点击网络设置-&amp;gt;内外网设置点击基于物理网卡的混合模式&#xA;好划到下面进行添加账号&#xA;点击添加（同一个账号也可以添加多次，名称随便取）&#xA;然后下划，点击保存就可以了&#xA;最后进入多线负载&#xA;需要填写的框框出来了&#xA;后续步骤 电脑连接你给电脑设置的lan口&#xA;接下来就大功告成了（看看有没有连接成功）&#xA;pve连接虚拟机ikuai的网络以及其他虚拟机连接ikuai的网络 虚拟机设置网络十分简单，只需要再添加一个网络设备（名称就是你ikuai的lan口对应的虚拟网卡名称）&#xA;pve连接就进入网络配置界面编辑&#xA;nano /etv/network/interfaces 下划，随便挑一个lan口对应的虚拟网卡名称把他原来的manual改成dhcp就行了</description>
    </item>
    <item>
      <title>记录linux建站时看依据网上教程可能疏漏的地方（docker篇）</title>
      <link>https://0ha.top/posts/130881434/</link>
      <pubDate>Tue, 27 Feb 2024 05:57:26 +0000</pubDate>
      <guid>https://0ha.top/posts/130881434/</guid>
      <description>设置docker时不设置自启动 由于有一部分冷门的教程比较少，有一些博主可能一疏忽，小白就会遇到一些各种各样的奇怪问题&#xA;就比如docker在创建时不设置开机自启&#xA;--restart always 在创建容器是看看有没有这一行代码&#xA;只要你想让你容器每次开机时或者因一些意外而终止时自动开启就必须要加上&#xA;比如我要创建一个alist的云盘&#xA;这个时候然后不设置开机自启就会出现但不限于————账号密码重置，挂载的存储丢失（应该是所有的设置全部初始化）&#xA;所以无论容器会不会自启最好在创建的时候加一句这个命令，或者创建好了就马上设置自启</description>
    </item>
    <item>
      <title>linux下hexo利用脚本快速部署到自己服务器的宝塔面板上</title>
      <link>https://0ha.top/posts/131397992/</link>
      <pubDate>Tue, 27 Feb 2024 05:29:11 +0000</pubDate>
      <guid>https://0ha.top/posts/131397992/</guid>
      <description>目录&#xA;步骤一&#xA;步骤二&#xA;步骤三&#xA;步骤四&#xA;步骤五&#xA;步骤六&#xA;用处&#xA;用于不想把hexo部署在GitHub（因为网络问题）从而部署到自己的服务器上&#xA;步骤一 宝塔先创建一个网站&#xA;因为hexo是纯静态的，所以记得改php版本&#xA;步骤二 在 /usr/local/bin/目录下创建脚本&#xA;hexo_qy.sh&#xA;nano /usr/local/bin/hexo_qy.sh 写入如下命令&#xA;cd /你在linux中hexo博客的目录/ hexo clean hexo g rm -rf 你创建的宝塔网站的文件目录（此命令用于删除文件）+ &amp;#34;*&amp;#34;(注意&amp;#34;*&amp;#34;号不能掉） cp -r /你在linux中hexo博客的目录/ /你在linux中hexo博客的目录/+&amp;#34;*&amp;#34;(注意&amp;#34;*&amp;#34;号不能掉） 步骤三 给予其权限&#xA;chmod 777 /usr/local/bin/hexo_qy.sh 步骤四 运行一下看看是否成功&#xA;/usr/local/bin/hexo_qy.sh 步骤五 修改名称加入环境变量并且删除.sh文件&#xA;cp /usr/local/bin/hexo_qy.sh /usr/local/bin/hexo_qy &amp;amp;&amp;amp; rm /usr/local/bin/hexo_qy.sh 给予其权限&#xA;chmod 777 /usr/local/bin/hexo_qy 步骤六 查看是否成功&#xA;在/root目录下输入&#xA;hexo_qy 查看是否把hexo的文件迁移到宝塔文件目录下了</description>
    </item>
    <item>
      <title>C&#43;&#43;中的pair 和make_pair的用法</title>
      <link>https://0ha.top/posts/131140285/</link>
      <pubDate>Mon, 26 Feb 2024 12:17:37 +0000</pubDate>
      <guid>https://0ha.top/posts/131140285/</guid>
      <description>pair的基础用法概念 pair可以把两个数据整合到一个变量中&#xA;注意只能是两个，多不行，少也不行 数据类型可同可不同&#xA;可以方便的进行数据管理&#xA;pair的基础定义以及逻辑关系 pair&#xA;通过p1 &amp;lt; p2;这个可以通俗的理解为第一个元素也就是first元素他的权重要比second的元素权重要大（也就是比大小优先比较他）&#xA;在定义少量的pair类型时可以用pair或者是pair来进行定义&#xA;如果要进行多个定义是可以用&#xA;typedef struct pair PAIR_X; 学到这里我才知道定义结构体的typedef是用于后面定义结构图时不用加struct（无关提及）&#xA;实战（代码） 为了方便理解我这用段代码来定义一个pair类型的变量并且赋值然后打印它的第一个元素&#xA;#include using namespace std; typedef struct pair PAIR_X; int main(void) { PAIR_X pair_1 =make_pair(0,3.14f); cout&amp;lt; pair定义可以更加方便并且快速的定制自己想要的数据类型（比如红黑树的类型定义&amp;hellip;）</description>
    </item>
    <item>
      <title>【已成功验证】debian/PVE安装好后拔显卡后连接不了网络（pve无显卡启动遇到的问题）</title>
      <link>https://0ha.top/posts/131796920/</link>
      <pubDate>Wed, 17 Jan 2024 09:14:43 +0000</pubDate>
      <guid>https://0ha.top/posts/131796920/</guid>
      <description>目录&#xA;前因&#xA;原因&#xA;解决办法&#xA;注意&#xA;需要主板bios支持跳过显卡自检&#xA;解决好主板bios问题然后再继续解决系统问题&#xA;前因 前几天装了个​Proxmox​ ve当做一个服务器7*24开机&#xA;但是由于转好系统后，显卡就不需要了&#xA;加上它耗电的原因（我的gtx650平时空载有10w左右的功耗）&#xA;我在想拔显卡拔了，我用xshell进行ssh连接不就可以了&#xA;然后我一拔，一开机，果然！&#xA;连接不上后台和ssh&#xA;看了一眼路由器，发现根本没他的网络地址&#xA;原因 后面我在搜贴吧相类似的问题，发现这是由于因为拔了显卡的pcie插槽从而导致网口号发生变化&#xA;由于pve是基于linux的debian系统下的，而现在的系统内的udev版本下网口号是按照位置来分的（很坑爹）&#xA;名称发生变化，但是你网络的配置文件又是之前的网卡名称的配置文件自然没有网络&#xA;于是就有了这么奇怪的一幕&#xA;解决办法 这个问题的解决办法也找到了，比较简单，就是把网口号和网口的mac地址给绑定在一起&#xA;首先查看网口名称的ip地址（注意不要看成网卡虚拟出来的地址了）&#xA;ip a 注意查看你本机ip对应mac地址的网卡名称（可能会有两个网卡一模一样的mac地址，我就是，两个都可以连接ssh；其中有一个是有问题的，如果设置成他的话，你创建的虚拟机无法开启连不了网。问题不大全部试一遍就行了，一般是enp开头的）&#xA;接下来打开配置文件夹&#xA;cd /etc/udev/rules.d 查看文件&#xA;ls 如果发现有其他的文件先用ls -l+文件名查看&#xA;如果发现他是一个链接文件并且指向/dev/null的话(就像下面那样）&#xA;lrwxrwxrwx 1 root root 9 Jul 18 21:49 60-bridge-network-interface.rules -&amp;gt; /dev/null 那可以把他删掉&#xA;rm 接下来创建一个文件（必须是这种&#xA;nano 50-bridge-network-interface.rules 然后写入下面的文字&#xA;SUBSYSTEM==&amp;#34;net&amp;#34;, ACTION==&amp;#34;add&amp;#34;, ATTR{address}==&amp;#34;mac地址&amp;#34;, NAME=&amp;#34;你的网卡名称&amp;#34; 重启&#xA;reboot 这样ip地址就绑定到这个网卡名称上了&#xA;注意 本博客只解决了linux中pcie改变，导致的网卡名称错乱的问题（博主确信就这个问题而言，已经解决了，但是博主还没成功开坤，所以怀疑还有其他诸如bios以及grub的问题）&#xA;设置好后要在bios选项中把halt on改成No Errors，也就是无论有什么错误先开机再说&#xA;可能有其他选项比如华南的x99在Advanced-&amp;gt;PCI Subsystem Settings-&amp;gt;Onboard VGA&#xA;把他关闭&#xA;其他bios的不知道了</description>
    </item>
    <item>
      <title>go-cqhttp作者停止维护——替代品OpenShamrock的使用方法</title>
      <link>https://0ha.top/posts/135416998/</link>
      <pubDate>Fri, 05 Jan 2024 12:37:55 +0000</pubDate>
      <guid>https://0ha.top/posts/135416998/</guid>
      <description>目录&#xA;前言&#xA;解决办法&#xA;配置要求&#xA;实操&#xA;刷入面具&#xA;安装lsp框架&#xA;安装OpenShamrock和QQ&#xA;注意&#xA;大功告成&#xA;前言 由于QQ官方针对协议库的围追堵截，go-cqhttp已经无力维护下去了&#xA;原文连接&#xA;QQ Bot的未来以及迁移建议 · Issue #2471 · Mrs4s/go-cqhttp (github.com)https://github.com/Mrs4s/go-cqhttp/issues/2471 ;目前签名服务器挂了，也就只有手表协议勉强可以跑，但是手表协议只要一天发了20多条消息就会风控发不了消息，这显然不能满足我们的需求。&#xA;那么还有没有解决办法呢？&#xA;解决办法 答案是有，可以借助OpenShamrock软件进行配置，当作qq的接收端以及发送端&#xA;OpenShamrock官网连接&#xA;首页 | OpenShamrock (whitechi73.github.io)https://whitechi73.github.io/OpenShamrock/;&#xA;配置要求 这里要求的配置要比之前部署的要高得多&#xA;首先部署的条件以及思想的利用手机app（需要lsp框架）来获取qq的消息以及发送消息&#xA;那么必然是需要完整的安卓环境的&#xA;那么有四个方法&#xA;利用pve来虚拟一个BlissOS虚拟机（安卓系统）并且root刷入lsp框架后安装OpenShamrock 在windows10中安装模拟器root后刷入lsp框架，安装OpenShamrock，然后登录qq获取消息 pve系统中安装windows并且开启嵌套虚拟化（用pvetools一键实现），再安装模拟器（最好有显卡直通，不然性能一言难尽），然后如上一个方法一样即可 有多余的手机root后刷入lsp安装OpenShamrock获取消息 当然不一定要root，LSPatch的免root也是一个不错的选择&#xA;实操 刷入面具 这里我已经安装好了mumu模拟器了&#xA;首先就要root需要打开设置然后设置以下两项&#xA;重启，然后下载面具app（其他的类面具的app诸如狐狸面具一样的操作）&#xA;安装好后重启（别按重启按钮——没啥用），关掉重新打开就行&#xA;再次进入时会显示弹窗&#xA;不用理会即可&#xA;设置打开开启Zygisk&#xA;然后重启&#xA;安装lsp框架 安装Zygisk版的lsp框架&#xA;LSPosed-v1.9.2-7055-zygisk-release.zip官方版下载丨最新版下载丨绿色版下载丨APP下载-123云盘123云盘为您提供LSPosed-v1.9.2-7055-zygisk-release.zip最新版正式版官方版绿色版下载,LSPosed-v1.9.2-7055-zygisk-release.zip安卓版手机版apk免费下载安装到手机,支持电脑端一键快捷安装https://www.123pan.com/s/HrkuVv-F2wX.html ;刷入即可&#xA;安装OpenShamrock和QQ 之后去官网（上面有）下载OpenShamrock并且安装&#xA;然后下载QQ并且登录账号&#xA;再lsp框架中开启OpenShamrock作用范围改为系统和QQ即可&#xA;注意 需要注意的是雷电模拟器应用市场下载的QQ会显示QQ版本过低（目前是），在官网下载的QQ登录的时候会死机（目前是），需要下载QQ8.9.83版本的（连接如下）&#xA;com.tencent.mobileqq_fe151f88-gp.apk官方版下载丨最新版下载丨绿色版下载丨APP下载-123云盘123云盘为您提供com.tencent.mobileqq_fe151f88-gp.apk最新版正式版官方版绿色版下载,com.tencent.mobileqq_fe151f88-gp.apk安卓版手机版apk免费下载安装到手机,支持电脑端一键快捷安装https://www.123pan.com/s/HrkuVv-Y2wX.html ;模拟器的如果要连接局域网的onebot之类的项目，网络需要改成桥接才可以连接。&#xA;大功告成 后面进入就可以选择了，基于onebot的反向代理地址/正向代理地址填写正确即可了，目前可以算的上是go-cqhttp效果的平替（速度会慢一点点)。异常的时候上模拟器处理会更加方便。&#xA;其他的手机按照这个教程改一下即可（你们应该会的&amp;hellip;&amp;hellip;)。&#xA;博主是一台pve上开了ubuntu（机器人服务器）+win10（模拟器）来挂机的。QAQ。</description>
    </item>
    <item>
      <title>PVE（Proxmox）8.0的一些问题汇总（持续更新中</title>
      <link>https://0ha.top/posts/133893950/</link>
      <pubDate>Thu, 04 Jan 2024 03:49:30 +0000</pubDate>
      <guid>https://0ha.top/posts/133893950/</guid>
      <description>目录&#xA;前言&#xA;杂谈&#xA;pve和esxi选啥&#xA;单pve系统问题（这一类问题比较玄学，我自己搞可以，你们试一试看，不保证行）&#xA;pve安装后网络连接不上&#xA;网口灯亮&#xA;如果网口灯不亮&#xA;pve老是死机卡住&#xA;直通类&#xA;显卡怎么直通&#xA;win10显卡报错43&#xA;直通后进不去系统或者系统有问题自救&#xA;pci类&#xA;拔了显卡开机了但是进不去系统&#xA;虚拟机类&#xA;虚拟机显示问号，而且创建不了新的虚拟机&#xA;我想用pve的虚拟机ikuai来连接pve怎么搞&#xA;win10/11问题汇总（就你事多&#xA;win11可不可以装&#xA;可不可以装windows server&#xA;win10有时性能会很卡&#xA;win10任务管理器的cpu显示一直在基准频率&#xA;前言 pve折腾了快有大半年了，汇总一下我遇到的问题和解决办法（最后更新时间：2024-1-4）&#xA;杂谈 pvetools是个好东西 它是可以帮助你省小不少事情的脚本&#xA;官方网站&#xA;GitHub - ivanhao/pvetools: proxmox ve tools script(debian9+ can use it).Including email, samba, NFS set zfs max ram, nested virtualization ,docker , pci passthrough etc. for english user,please look the end of readme.proxmox ve tools script(debian9+ can use it).Including email, samba, NFS set zfs max ram, nested virtualization ,docker , pci passthrough etc.</description>
    </item>
    <item>
      <title>C&#43;&#43;局域网从服务器获取已连接用户的列表（linux to linux）</title>
      <link>https://0ha.top/posts/134625871/</link>
      <pubDate>Sun, 26 Nov 2023 04:20:21 +0000</pubDate>
      <guid>https://0ha.top/posts/134625871/</guid>
      <description>目录&#xA;服务器端&#xA;代码&#xA;客户端&#xA;代码解析&#xA;服务器端&#xA;原理&#xA;遇到的阻碍以及解决办法&#xA;客户端&#xA;原理&#xA;遇到的阻碍以及解决办法&#xA;运行结果截图&#xA;总结&#xA;服务器端 代码 #include #include #include #include #include #include #include #include #include #include #include #include #include using namespace std; #define PORT 8806 #define IP &amp;#34;127.0.0.1&amp;#34; int msocket; struct sockaddr_in servaddr; socklen_t m_len; list connList; void addPerson(){ while(1){ int f_socket=accept(msocket,(struct sockaddr *) &amp;amp;servaddr,&amp;amp;m_len); connList.push_back(f_socket); cout&amp;lt;::iterator it; while(true){ for(it=connList.begin();it!=connList.end();it++){ fd_set rds; FD_ZERO(&amp;amp;rds); int max_fd=0; int reval=0; FD_SET(*it,&amp;amp;rds); if(*it&amp;gt;max_fd){ max_fd=*it; } reval=select(max_fd+1,&amp;amp;rds,NULL,NULL,&amp;amp;tv); if(reval==-1){ cout&amp;lt;0){ if(buf[0]==&amp;#39;#&amp;#39;){ sendList(*it); } cout&amp;lt; 客户端 #include #include #include #include #include #include #include using namespace std; #define PORT 8806 int main(){ int socket_1; fd_set rds; FD_ZERO(&amp;amp;rds); struct timeval tv; socket_1=socket(AF_INET,SOCK_STREAM,0); struct sockaddr_in servaddr; servaddr.</description>
    </item>
    <item>
      <title>【C&#43;&#43;】多线程的学习笔记（3）——白话文版（bushi</title>
      <link>https://0ha.top/posts/134416481/</link>
      <pubDate>Sat, 18 Nov 2023 02:04:09 +0000</pubDate>
      <guid>https://0ha.top/posts/134416481/</guid>
      <description>目录&#xA;前一篇内容（mutex锁）&#xA;前言&#xA;Condition Variable的简介&#xA;Condition Variable的使用方法&#xA;wait方法&#xA;wait for函数与wait until函数&#xA;notify函数&#xA;notify_one&#xA;notify_all&#xA;注意&#xA;前一篇内容（mutex锁） 【C++】多线程的学习笔记（2）——白话文版（bushi-CSDN博客文章浏览阅读161次。lock_guard是模板类，对比于mutex的区别是lock_guard在创建时会尝试获得锁的所有权（注意时尝试，如果获取不到就相当于没有用，并且不会报错），在作用域结束时会自动析构，无需手动解锁该类不可中途上锁和解锁，不可复制unique_lock的用法和lock_guard的用法类似，主要的区别在于他可以中途上锁以及解锁对比于lock_guard会更加的灵活但是所需要的内存空间会更大同时它的也有adopt_lock参数用法一样，而且他还拥有其他的第二参数。https://blog.csdn.net/mumuemhaha/article/details/133554220?spm=1001.2014.3001.5501 ;&#xA;前言 好久没有继续写博客了，原因就是去沉淀了一下偷懒了一下&#xA;现在在学网络编程，c++的多线程也还在学&#xA;这一变博客就讲讲c++中的Condition Variable库吧&#xA;Condition Variable的简介 官方原文解释&#xA;翻译就是&#xA;_条件变量_是一个对象，它能够阻止调用线程，直到 _通知_恢复。&#xA;当调用线程的一个 _ 等待函数时，它使用 （mutex ） 来锁定线程。该线程将保持阻塞状态，直到被另一个线程唤醒，该线程对同一对象调用 _ 通知函数。&#xA;这里我们可以看到Condition Variable一般是要和mute锁配合使用来发挥他的最大用处&#xA;Condition Variable的使用方法 wait方法 wait方法的原型为两种&#xA;void wait (unique_lock&amp;amp; lck); template void wait (unique_lock&amp;amp; lck, Predicate pred); 第一种为他只是传递一个mutex锁(注意是unique_lock锁）来锁定自己，也就是堵塞当前的线程，直到自己被notify(下面要讲到的函数)唤醒。&#xA;第二种和第一种差不多不过他多了一个predicate的参数，这里可以是一个函数，类型为true或者false，我画了一张并不是很准确的图片可以帮助理解一下&#xA;大部分时候为了缩短代码的长度他一般会写出lambda表达式，也就是类似与[x] () { x=1; };这样的表达式&#xA;它可以等效为&#xA;bool F_1(int x){ return x=1 } 其中的lambda表达式有许多用法——诸如捕获前面的变量，传递以及引用；这里不多做赘述，论坛里有许多相关的文章，这里提一嘴主要是让读者知道这是一个什么东西，好搜索相应的教程。&#xA;wait for函数与wait until函数 wait for函数原型</description>
    </item>
    <item>
      <title>【C&#43;&#43;】多线程的学习笔记——白话文版（bushi</title>
      <link>https://0ha.top/posts/133468825/</link>
      <pubDate>Wed, 04 Oct 2023 13:35:04 +0000</pubDate>
      <guid>https://0ha.top/posts/133468825/</guid>
      <description>目录&#xA;下一章内容&#xA;为什么要使用多线程&#xA;例子&#xA;代码&#xA;结果&#xA;首先要先学的库——thread库&#xA;thread的简介&#xA;thread的具体使用方法&#xA;基本变量的定义&#xA;注意（小重点）&#xA;join函数的解读（重点）&#xA;detach函数的解读&#xA;注意&#xA;关于vector和thread是联合使用&#xA;例子中代码的改良&#xA;代码&#xA;运行结果&#xA;总结&#xA;是不是少了什么？&#xA;下一章内容 【C++】多线程的学习笔记（2）——白话文版（bushi-CSDN博客lock_guard是模板类，对比于mutex的区别是lock_guard在创建时会尝试获得锁的所有权（注意时尝试，如果获取不到就相当于没有用，并且不会报错），在作用域结束时会自动析构，无需手动解锁该类不可中途上锁和解锁，不可复制unique_lock的用法和lock_guard的用法类似，主要的区别在于他可以中途上锁以及解锁对比于lock_guard会更加的灵活但是所需要的内存空间会更大同时它的也有adopt_lock参数用法一样，而且他还拥有其他的第二参数。https://blog.csdn.net/mumuemhaha/article/details/133554220?spm=1001.2014.3001.5501 ;&#xA;为什么要使用多线程 在我们实际处理问题中可能会遇到一些需要等待或者是需要时间去等待放回的问题&#xA;比如像网络爬虫的数据包返回，亦或者程序对cpu的使用率不高，导致时间和性能的浪费&#xA;同时多线程可以实现异步编程，将一些耗时的操作放在后台线程执行，使得主线程能够继续响应用户的其他操作，提高程序的并发性。&#xA;综上所述，多线程编程对于我们大部分编程语言的学习都是必须要学习的。&#xA;例子 在这里我先放一个源代码在这，这是我们用原先的方法进行顺序执行&#xA;代码 #include #include #include using namespace std; void F_1(int i) { this_thread::sleep_for(chrono::seconds(i));//设定程序需要运行的时间 cout &amp;lt;&amp;lt; &amp;#34;The No.&amp;#34;&amp;lt; 其中time.h库中的clock_t以及clock()是是用来统计程序运行的时间的 this_thread::sleep_for(chrono::seconds(i))这个函数是个休眠函数，为等待i秒，用来模拟程序运行的时间&#xA;结果 程序运行的结果&#xA;如图程序一共运行了6000ms的时间&#xA;首先要先学的库——thread库 thread的简介 C++ 作为一种强大的编程语言，为多线程编程提供了丰富而灵活的支持。C++ 的标准库提供了 &amp;lt;thread&amp;gt;&amp;lt;/thread&amp;gt; 头文件，其中包含了用于创建、启动和管理线程的类和函数。通过使用这些多线程库和功能，开发人员可以轻松地引入并发性到自己的应用程序中，实现多线程的并行处理。&#xA;thread的具体使用方法 基本变量的定义 thread函数中定义线程的语法规如下&#xA;std::thread 变量名 (函数，传递的参数1，传递的参数2，传递的参数3...）【如果前面加了using namespace std;可以删除std::】 注意（小重点） 其中如果原函数传递的参数为左值（也就是int &amp;amp;a）那么传递的参数应该把原来的a，b&amp;hellip;改为ref(a),ref（b）或者cref(a),cref(b)&amp;hellip;&#xA;原因是thread为右值传递，函数讲道理应该不能用引用也就是右值。</description>
    </item>
    <item>
      <title>【C&#43;&#43;】多线程的学习笔记（2）——白话文版（bushi</title>
      <link>https://0ha.top/posts/133554220/</link>
      <pubDate>Wed, 04 Oct 2023 09:27:48 +0000</pubDate>
      <guid>https://0ha.top/posts/133554220/</guid>
      <description>目录&#xA;前一篇&#xA;本章内容提要&#xA;使用mutex锁的原因&#xA;mutex锁的概念&#xA;mutex的使用教程&#xA;锁的声明以及命名&#xA;mutex的加锁以及解锁&#xA;例子&#xA;结果&#xA;注意&#xA;mutex的其他方式的锁介绍&#xA;lock_guard&#xA;介绍&#xA;例子&#xA;运行结果&#xA;adopt_lock参数&#xA;unique_lock&#xA;介绍&#xA;try_to_lock&#xA;defer_lock&#xA;release&#xA;例子&#xA;结果&#xA;总结&#xA;前一篇 第一篇在这&#xA;【C++】多线程的学习笔记——白话文版（bushi-CSDN博客C++ 作为一种强大的编程语言，为多线程编程提供了丰富而灵活的支持。C++ 的标准库提供了头文件，其中包含了用于创建、启动和管理线程的类和函数。通过使用这些多线程库和功能，开发人员可以轻松地引入并发性到自己的应用程序中，实现多线程的并行处理。thread函数中定义线程的语法规如下std::thread 变量名 (函数，传递的参数1，传递的参数2，传递的参数3&amp;hellip;）【如果前面加了using namespace std;可以删除std::】https://blog.csdn.net/mumuemhaha/article/details/133468825?spm=1001.2014.3001.5502 ;&#xA;本章内容提要 上一章我们讲解了如何利用thread库初步进行多线程操作&#xA;这一章，我们主要讲的是锁（其实就是mutex锁）的概念&#xA;使用mutex锁的原因 在上一章的多线程操作中我们也许会想到一个问题——如果变量或者资源他不是独占的，而是共享的（比如对于全局变量的修改），那么如果多个线程同时访问就会引起不可预料的错误&#xA;这个时候就必须要给线程进行加锁确保只能有一个线程运行此函数。&#xA;mutex锁的概念 Mutex（互斥锁）是一种线程同步机制，用于保护共享资源的访问，防止多个线程同时访问和修改同一份数据而引发竞争条件（race condition）。 Mutex 的作用是在关键代码段前后加锁和解锁操作，确保只有一个线程能够进入临界区（critical section）执行代码，从而保证共享资源的安全访问。&#xA;同一时刻，同一临界区，只能有一个线程持有该锁&#xA;mutex的使用教程 锁的声明以及命名 开头必然要声明库函数&#xA;#include 和其他类型的变量一样，之后锁还需要声明一个变量&#xA;mutex mtx_1; 这个最好是在全局变量中进行声明&#xA;mutex的加锁以及解锁 在你写函数需要加锁时你只需要调用他们当中的lock(),以及unlck()，如果在执行lock时候如果锁已经被其他线程获取了，那么线程会进行等待&#xA;拿上面的进行举例就是&#xA;mtx_1.lock();//加锁 mtx_1.unlock();//解锁 例子 运行一个&#xA;#include #include #include #include #include using namespace std; mutex mtx_1; void F_1(int i) { mtx_1.</description>
    </item>
    <item>
      <title>我的创作纪念日</title>
      <link>https://0ha.top/posts/133235248/</link>
      <pubDate>Sun, 24 Sep 2023 03:28:05 +0000</pubDate>
      <guid>https://0ha.top/posts/133235248/</guid>
      <description>机缘 本来是抱着分享的态度搞这些的&#xA;学习的知识可以分享出来&#xA;而分享出来的成就感又激励我学习&#xA;至于我的第一篇博客现在看看对比与现在可以说是变化比较大了&#xA;（虽然现在依旧不咋地。。。）&#xA;收获 到现在也快有3000多粉了&#xA;挺感慨的，记得那时候也是什么都不懂的小白，甚至搜索的内容都看不懂&#xA;现在——。。。小白变大白？&#xA;咳咳&amp;hellip;&amp;hellip;写博客既可以当一个记录自己成长的过程&#xA;在后续工作面试也是你的加分项&#xA;并且督促自己学习&#xA;日常 目前是在校不知名二本大学生——大三，计算机专业，大二的时候有一段时间搞网站的相关维护&#xA;域名，DNS，以及路由器交换机都是那个时候学到的，几乎算是把大部分时间花在那上面了&#xA;现在的话更新频率少了（主要是现在在刷算法题目以及备战考研，没太多时间去写了）&#xA;成就 成就就不说了，可以看看我的博客，没啥能拿出手的，都是一些入门的教程以及一些bug错误调试&#xA;憧憬 目前准备考研，或者找一份适合自己的工作吧&#xA;最后附上我平时经常用的猫猫虫~~</description>
    </item>
    <item>
      <title>只用纯python实现一次函数的梯度下降</title>
      <link>https://0ha.top/posts/130772714/</link>
      <pubDate>Sun, 17 Sep 2023 15:10:45 +0000</pubDate>
      <guid>https://0ha.top/posts/130772714/</guid>
      <description>代码：&#xA;或者可以用导数的定义来求&#xA;可能出现的问题&#xA;安装其他的库&#xA;代码： #&amp;amp;#x4E00;&amp;amp;#x6B21;&amp;amp;#x51FD;&amp;amp;#x6570;&#xD;import matplotlib.pyplot as plt #&amp;amp;#x5BFC;&amp;amp;#x5165;&amp;amp;#x5E93;&#xD;import numpy as np&#xD;def f_shunshi(): #&amp;amp;#x635F;&amp;amp;#x5931;&amp;amp;#x51FD;&amp;amp;#x6570;&amp;amp;#xFF08;&amp;amp;#x6CA1;&amp;amp;#x7528;&amp;amp;#x5230;&amp;amp;#xFF09;&#xD;return np.sum(1.0/2.0*(f_w*Sum_shuju_X+f_b-Sum_shuju_Y)*(f_w*Sum_shuju_X+f_b-Sum_shuju_Y)/10)&#xD;def f_daoshu_w(): #&amp;amp;#x5173;&amp;amp;#x4E8E;&amp;amp;#x4E00;&amp;amp;#x6B21;&amp;amp;#x51FD;&amp;amp;#x6570;w&amp;amp;#xFF08;&amp;amp;#x659C;&amp;amp;#x7387;&amp;amp;#xFF09;&amp;amp;#x7684;&amp;amp;#x504F;&amp;amp;#x5BFC;&#xD;return np.sum(f_w*(f_w*Sum_shuju_X+f_b-Sum_shuju_Y))/10&#xD;def f_daoshu_b(): #&amp;amp;#x5173;&amp;amp;#x4E8E;&amp;amp;#x4E00;&amp;amp;#x6B21;&amp;amp;#x51FD;&amp;amp;#x6570;b&amp;amp;#xFF08;&amp;amp;#x504F;&amp;amp;#x79FB;&amp;amp;#x91CF;&amp;amp;#xFF09;&amp;amp;#x7684;&amp;amp;#x504F;&amp;amp;#x5BFC;&#xD;return np.sum(f_w*Sum_shuju_X+f_b-Sum_shuju_Y)/10&#xD;xuexilv=1e-2 #&amp;amp;#x5B66;&amp;amp;#x4E60;&amp;amp;#x7387;&#xD;f_w=1.0 #&amp;amp;#x51FD;&amp;amp;#x6570;&amp;amp;#x521D;&amp;amp;#x59CB;&amp;amp;#x53C2;&amp;amp;#x6570;&#xD;f_b=1.0&#xD;print(&amp;#34;&amp;amp;#x8F93;&amp;amp;#x5165;10&amp;amp;#x4E2A;&amp;amp;#x6570;&amp;amp;#x636E;&amp;#34;)&#xD;Sum_shuju=np.empty([0,2],dtype=float) #&amp;amp;#x521B;&amp;amp;#x5EFA;&amp;amp;#x4E00;&amp;amp;#x4E2A;&amp;amp;#x5927;&amp;amp;#x6570;&amp;amp;#x636E;&amp;amp;#x7528;&amp;amp;#x6765;&amp;amp;#x5B58;&amp;amp;#x653E;x&amp;amp;#x548C;y&amp;amp;#xFF09;&#xD;shuju=np.array([]) #&amp;amp;#x4E34;&amp;amp;#x65F6;&amp;amp;#x53C2;&amp;amp;#x6570;&#xD;for i in range(0, 10): #&amp;amp;#x63D2;&amp;amp;#x5165;10&amp;amp;#x4E2A;&amp;amp;#x6570;&amp;amp;#x636E;&amp;amp;#xFF08;&amp;amp;#x53EF;&amp;amp;#x53D8;&amp;amp;#xFF09;&#xD;print(f&amp;#34;&amp;amp;#x7B2C; {i + 1}&amp;amp;#x4E2A;&amp;amp;#x6570;&amp;amp;#x636E;&amp;#34;)&#xD;x1 = input(&amp;#34;&amp;amp;#x8F93;&amp;amp;#x5165;x:&amp;#34;)&#xD;x1=float(x1)&#xD;shuju=np.append(shuju,x1)&#xD;y1 = input(&amp;#34;&amp;amp;#x8F93;&amp;amp;#x5165;y:&amp;#34;)&#xD;y1=float(y1)&#xD;shuju=np.append(shuju,y1)&#xD;Sum_shuju=np.append(Sum_shuju,[shuju],axis=0)&#xD;shuju = np.array([])&#xD;print(&amp;#34;&amp;amp;#x6570;&amp;amp;#x636E;&amp;#34;)&#xD;print(Sum_shuju) #&amp;amp;#x9A8C;&amp;amp;#x8BC1;&amp;amp;#x6570;&amp;amp;#x636E;&amp;amp;#x6709;&amp;amp;#x65E0;&amp;amp;#x63D2;&amp;amp;#x5165;&amp;amp;#x9519;&amp;amp;#x8BEF;&#xD;x=input(&amp;#34;&amp;amp;#x662F;&amp;amp;#x5426;&amp;amp;#x8BBE;&amp;amp;#x7F6E;&amp;amp;#x51FD;&amp;amp;#x6570;&amp;amp;#x521D;&amp;amp;#x59CB;&amp;amp;#x53C2;&amp;amp;#x6570;&amp;amp;#xFF1A;0/&amp;amp;#x662F;&amp;amp;#xFF1B;1/&amp;amp;#x5426;&amp;amp;#xFF08;&amp;amp;#x9ED8;&amp;amp;#x8BA4;w=1&amp;amp;#xFF0C;b=1&amp;amp;#xFF09;:&amp;#34;)&#xD;if x==0:&#xD;f_w=input(&amp;#34;&amp;amp;#x8F93;&amp;amp;#x5165;w&amp;amp;#xFF08;&amp;amp;#x659C;&amp;amp;#x7387;&amp;amp;#xFF09;:&amp;#34;)&#xD;f_w=float(f_w)&#xD;f_b=input(&amp;#34;&amp;amp;#x8F93;&amp;amp;#x5165;b&amp;amp;#xFF08;&amp;amp;#x504F;&amp;amp;#x79FB;&amp;amp;#x91CF;&amp;amp;#xFF09;&amp;#34;)&#xD;f_b=float(f_b)&#xD;Sum_shuju_X=Sum_shuju[:,0]&#xD;Sum_shuju_Y=Sum_shuju[:,1] #&amp;amp;#x628A;x&amp;amp;#x4E0E;y&amp;amp;#x63D0;&amp;amp;#x53D6;&amp;amp;#x5230;&amp;amp;#x4E24;&amp;amp;#x4E2A;&amp;amp;#x6570;&amp;amp;#x7EC4;&#xD;sum_1=input(&amp;#34;&amp;amp;#x8BBE;&amp;amp;#x7F6E;&amp;amp;#x8FED;&amp;amp;#x4EE3;&amp;amp;#x6B21;&amp;amp;#x6570;&amp;amp;#xFF1A;&amp;#34;)&#xD;sum_1=int(sum_1)&#xD;print(f&amp;#34;w&amp;amp;#x7684;&amp;amp;#x503C;&amp;amp;#x4E3A;:{f_w}&amp;#34;)&#xD;print(f&amp;#34;b&amp;amp;#x7684;&amp;amp;#x503C;&amp;amp;#x4E3A;:{f_b}&amp;#34;)&#xD;f_w_sum=np.</description>
    </item>
    <item>
      <title>【力扣】三角形最小路径和</title>
      <link>https://0ha.top/posts/132921886/</link>
      <pubDate>Sat, 16 Sep 2023 10:43:30 +0000</pubDate>
      <guid>https://0ha.top/posts/132921886/</guid>
      <description>目录&#xA;题目&#xA;例子&#xA;示例 1：&#xA;示例 2：&#xA;前言&#xA;思路&#xA;思想&#xA;代码&#xA;调用的函数&#xA;主函数&#xA;所有代码&#xA;力扣提交的代码&#xA;运行结果&#xA;小结&#xA;题目 给定一个三角形 triangle ，找出自顶向下的最小路径和。 每一步只能移动到下一行中相邻的结点上。 相邻的结点在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。&#xA;例子 示例 1： 输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]&#xD;输出：11&#xD;解释：如下面简图所示：&#xD;2&#xD;3 4&#xD;6 5 7&#xD;4 1 8 3&#xD;自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 示例 2： 输入：triangle = [[-10]]&#xD;输出：-10 前言 本题是动态规划的一道经典题目，最早出现在1994年的ioi比赛中</description>
    </item>
    <item>
      <title>超详细——在WordPress网站上添加看板娘</title>
      <link>https://0ha.top/posts/131050625/</link>
      <pubDate>Thu, 14 Sep 2023 03:45:01 +0000</pubDate>
      <guid>https://0ha.top/posts/131050625/</guid>
      <description>目录&#xA;下载文件&#xA;注意&#xA;配置文件&#xA;设置头文件&#xA;第二种方法（部分主题支持，比较简单）&#xA;下载文件 首先去下载相应的文件&#xA;这里借用一下其他博主的文件&#xA;mumuhaha487/KanBanMusume: WordPress添加看板娘 (github.com)https://github.com/mumuhaha487/KanBanMusume ;把压缩包里面的文件改成&amp;quot;live2d&amp;quot;&#xA;方便后续操作&#xA;注意 之后上传到你的站点的目录下&#xA;需要确定的是你文件夹里的css文件或者model文件可以用链接来访问到&#xA;这里用宝塔举例&#xA;配置文件 设置头文件 之后打开 wp-content/themes/[WordPress&amp;amp;#x4F7F;&amp;amp;#x7528;&amp;amp;#x7684;&amp;amp;#x4E3B;&amp;amp;#x9898;&amp;amp;#x540D;&amp;amp;#x79F0;]/header.php&#xA;在 &amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;和 之中添加以下代码（可以ctrl+f搜索），将代码中 src 属性的 url 更换成你自己的（改完了直接粘贴到 &amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;下面就行）&#xA;href可改可不改，也可以用你自己的也可以用我的，需要注意的是要确定你链接的jqury.js文件可以访问就和我的http://zhuye.0ha.top:8849/wp-content/live2d/css/live2d.css&#xA;上面的链接访问不了了，现在直接用你自己的域名替换就行&#xA;链接一样&#xA;之后保存退出&#xA;再打开同目录下的footer.php文件&#xA;在前面加入如下内容（要把&amp;quot;var home_Path&amp;quot;改为你的域名）&#xA;隐藏 换装 var message_Path = &amp;#39;/live2d/&amp;#39; var home_Path = &amp;#39;http://www.aaa.com&amp;#39; //此处修改为你的域名 var index = Math.ceil(Math.random()*37) //index表示服装编号，此处表示随机切换服装 loadlive2d(&amp;#34;live2d&amp;#34;, &amp;#34;live2d/model/pio/model_&amp;#34;+index+&amp;#34;.json&amp;#34;); 第二种方法（部分主题支持，比较简单） 还是要把之前的文件下载好然后在主题设置那里&#xA;输入下面代码&#xA;L2Dwidget.init({ &amp;#34;model&amp;#34;: { //jsonpath控制显示那个小萝莉模型， //(切换模型需要改动) // &amp;#34;https://unpkg.com/(live2d-widget-model-koharu)@1.0.5/assets/(koharu).model.json&amp;#34; jsonPath: &amp;#34;&amp;#34;,//模型链接最重要的！！！！！！！！！！ &amp;#34;scale&amp;#34;: 1 }, &amp;#34;display&amp;#34;: { &amp;#34;position&amp;#34;: &amp;#34;&amp;#34;, //看板娘的表现位置（left/right/空） &amp;#34;width&amp;#34;: 100, //小萝莉的宽度 &amp;#34;height&amp;#34;: 200, //小萝莉的高度 &amp;#34;hOffset&amp;#34;: -50, &amp;#34;vOffset&amp;#34;: -120 }, &amp;#34;mobile&amp;#34;: { &amp;#34;show&amp;#34;: true, &amp;#34;scale&amp;#34;: 0.</description>
    </item>
    <item>
      <title>[C&#43;&#43;]杨辉三角</title>
      <link>https://0ha.top/posts/132730011/</link>
      <pubDate>Thu, 07 Sep 2023 02:10:50 +0000</pubDate>
      <guid>https://0ha.top/posts/132730011/</guid>
      <description>目录&#xA;题目&#xA;解题思路&#xA;代码实现&#xA;获取数字&#xA;打印函数&#xA;主函数&#xA;全部代码&#xA;运行结果&#xA;题目 给定一个非负整数numRows ，生成「杨辉三角」的前numRows行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。 解题思路 第k列的第i个数字的值第k-1列的(i-1)和i的和&#xA;由于数组是动态变化的没有固定大小&#xA;运用到容器(vector)&#xA;u1s1！&#xA;python会比c好打&#xA;代码实现 获取数字 获取数并且把它存储到容器中&#xA;void GetResult(int a) { vector &amp;gt; sums; int b[1] = { 1 }; int c[2] = { 1,1 }; int d[3] = { 1,2,1 }; vector a_1(b,b+1); vector a_2(c,c+2); vector a_3(d,d+3); sums.push_back(a_1); sums.push_back(a_2); sums.push_back(a_3); for (int i = 3; i sum ; for (int j = 0; j 这里是容器里面又装载了一个容器</description>
    </item>
    <item>
      <title>【力扣】两数相除（c/c&#43;&#43;)</title>
      <link>https://0ha.top/posts/132647290/</link>
      <pubDate>Sun, 03 Sep 2023 04:30:50 +0000</pubDate>
      <guid>https://0ha.top/posts/132647290/</guid>
      <description>注意：&#xA;示例 1:&#xA;示例 2:&#xA;提示：&#xA;题目解析&#xA;题目思路&#xA;代码思路&#xA;数据处理&#xA;减法函数&#xA;第一次使用的函数&#xA;第二次改良后的代码&#xA;处理i的值并且返回&#xA;总代码&#xA;力扣的代码&#xA;给你两个整数，被除数 dividend 和除数 divisor。将两数相除，要求 不使用 乘法、除法和取余运算。 整数除法应该向零截断，也就是截去（ truncate）其小数部分。例如， 8.345 将被截断为 8 ， -2.7335 将被截断至 -2 。 返回被除数 dividend 除以除数 divisor 得到的 商 。&#xA;假设我们的环境只能存储 32 位 有符号整数，其数值范围是 [&amp;amp;#x2212;231,&amp;amp;#xA0; 231&amp;amp;#xA0;&amp;amp;#x2212; 1] 。本题中，如果商 严格大于 231&amp;amp;#xA0;&amp;amp;#x2212; 1 ，则返回 231&amp;amp;#xA0;&amp;amp;#x2212; 1 ；如果商 严格小于 -231 ，则返回 -231 。&#xA;输入: dividend = 10, divisor = 3&#xD;输出: 3&#xD;解释: 10/3 = 3.</description>
    </item>
    <item>
      <title>把c&#43;&#43;的函数导出为dll文件</title>
      <link>https://0ha.top/posts/132636931/</link>
      <pubDate>Sat, 02 Sep 2023 10:07:38 +0000</pubDate>
      <guid>https://0ha.top/posts/132636931/</guid>
      <description>目录&#xA;什么是dll文件&#xA;把c++函数变为dll有什么好处&#xA;开始教程&#xA;打开Visual Studio 2022创建&#xA;调整编译器设置&#xA;创建头文件&#xA;DLL1.h&#xA;创建源文件编辑函数内容&#xA;DLL1.cpp&#xA;编译成dll文件&#xA;什么是dll文件 DLL（Dynamic Link Library，动态链接库）是一种包含可被多个程序共享的代码和数据的文件格式。它可以被动态链接到程序中，在程序运行时提供所需的功能和服务。DLL 文件通常包含函数、类、变量和资源等，可以被其他程序调用和使用。使用 DLL 可以实现代码的复用、模块化开发和提高程序性能等好处。&#xA;把c++函数变为dll有什么好处 代码复用：通过将函数导出为 DLL，可以将函数封装在独立的库中，供其他程序重复使用，避免重复实现相同的功能，提高代码的复用性。 模块化开发：将函数导出为 DLL 可以帮助实现模块化开发，即将程序划分为多个模块，每个模块对应一个或多个 DLL，方便团队协作，每个人负责不同的模块。 提高性能：将常用的函数导出为 DLL，可以提高程序的运行效率。由于 DLL 是被动态链接的，它们可以被多个程序共享，减少内存使用。 保护知识产权：通过将核心代码封装在 DLL 中，可以保护知识产权，只将 DLL 提供给需要的人使用，不需要对源代码进行公开。 并且在python中你可以调用你自己编写的dll文件从而既可以最大的加快代码的运行速度（因为是用C++写的快了不止一点），又能达到你想要的效果。&#xA;开始教程 打开Visual Studio 2022创建 打开Visual Studio 2022选择创建新项目&#xA;搜索dll或者动态链接库&#xA;我选择的是第一个&#xA;进入后出现了&#xA;除了划红线的&#xA;其他的打开会自己创建&#xA;调整编译器设置 进入调试中的调试属性&#xA;确保红框一致&#xA;（如果是64位就最好是64位）&#xA;创建头文件 头文件结构为&#xA;DLL1.h #pragma once #ifndef _DLL1_H #define _DLL1_H #define DLL1_API extern &amp;#34;C&amp;#34; _declspec(dllexport) DLL1_API double Add_sum(int n); #endif // DEBUG 其中开头的</description>
    </item>
    <item>
      <title>简单的学习一下用python做一些后台挂机的项目</title>
      <link>https://0ha.top/posts/132549220/</link>
      <pubDate>Mon, 28 Aug 2023 14:42:38 +0000</pubDate>
      <guid>https://0ha.top/posts/132549220/</guid>
      <description>目录&#xA;前言&#xA;声明&#xA;前因&#xA;找python包&#xA;选择原因&#xA;代码&#xA;test_1.py&#xA;简单的代码解析&#xA;def Gethandle()&#xA;def GetClick(handle)&#xA;def doClick(cx, cy ,handle)&#xA;def runTest_1()&#xA;运行代码的一些问题&#xA;一些想法&#xA;前言 本篇博客只是记录我的学习win32包时写下的代码&#xA;声明 部分代码参考了这个博主的博客&#xA;python使用win32后台鼠标点击梦幻西游（只用于开学习技术）新手学习_win32模拟梦幻点击事件_weixin_47344599的博客-CSDN博客软件准备需要用到的软件PyCharm，梦幻西游手游客户端需要安装的库pip install pywin32直接上代码吧，里面都注释好了注意！！！！！需要登录到游戏账号后才能正确点击原因是登录界面需要重新抓取窗口句柄代码有些乱，但是都还好，自行优化吧能用=import win32guiimport win32conimport win32apiimport timeimpo&amp;hellip;_win32模拟梦幻点击事件https://blog.csdn.net/weixin_47344599/article/details/105926993 ;&#xA;自认为这位大佬写的代码有挺多区别的&#xA;但是这位博主看到了，如果觉得还是不行。联系我进行修改。&#xA;前因 由于自己最近在玩崩铁&#xA;近几年的米家游戏都不能跳过剧情（烦~&#xA;按键精灵是个好东西，但是他必须要前台挂着（得寸进尺。。。&#xA;我想要做的是我一边挂着剧情后台自动点击，一边做其他的事情（很美好嘞&#xA;然后一如既往出了一系列问题（不然我觉得早就有人做出来了，目前就卡在这，以下是我的探索过程）&#xA;找python包 然后我就找python包&#xA;找啊找&amp;hellip;&amp;hellip;&#xA;找到两类包&#xA;一个pyautogui包&#xA;一个就是pypiwin32包&#xA;两个包我考虑了一会&#xA;最终想试试pypiwin32包&#xA;选择原因 因为我看了一下第一种包的使用教程以及例子（只是浅浅的看了一下，没有深看，如果有的话轻点喷）发现他也是类似与按键精灵的那种模拟键盘的点击&#xA;那不都差不多吗？&#xA;然后我就选择了可以后台向固定窗口发送后台点击信息的win32包&#xA;然后我就试着打了一段代码&#xA;代码 test_1.py import win32gui import win32con import win32api import time #获取句柄 def Gethandle(): time_1=5 print(&amp;#34;五秒后，把鼠标移动到窗口处定位窗口句柄&amp;#34;) for i in range(1,time_1): time.</description>
    </item>
    <item>
      <title>【力扣】盛最多水的容器</title>
      <link>https://0ha.top/posts/132513438/</link>
      <pubDate>Sat, 26 Aug 2023 09:27:02 +0000</pubDate>
      <guid>https://0ha.top/posts/132513438/</guid>
      <description>目录&#xA;题目&#xA;题目初步解析&#xA;水桶效应&#xA;代码实现逻辑&#xA;第一步&#xA;第二步&#xA;第三步&#xA;代码具体实现&#xA;注意&#xA;添加容器元素的函数&#xA;计算迭代并且判断面积是否是最大值&#xA;总代码&#xA;运行结果&#xA;总结&#xA;题目 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 **说明：**你不能倾斜容器。&#xA;输入：[1,8,6,2,5,4,8,3,7]&#xD;输出：49&#xD;解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 题目初步解析 这一道题就是我们小时候常常说的水桶效应&#xA;水桶效应 水桶效应是指一只水桶想盛满水，必须每块木板都一样平齐且无破损，如果这只桶的木板中有一块不齐或者某块木板下面有破洞，这只桶就无法盛满水。是说一只水桶能盛多少水，并不取决于最长的那块木板，而是取决于最短的那块木板。也可称为短板效应。一个水桶无论有多高，它盛水的高度取决于其中最低的那块木板。&#xA;这就是我们要利用的思想来解答题目&#xA;代码实现逻辑 这是一个运用到双指针思想的问题（不一定用指针）&#xA;第一步 可以在数组的两侧（开头以及末尾）标记两个指针（或者记录下标）&#xA;然后计算面积&#xA;第二步 此时当然不能说这是最大的面积&#xA;我们要进行遍历&#xA;那怎么遍历呢？&#xA;还记得我们刚刚说的木头效应吗？&#xA;你装下的水取决于的是你最小的那一块木板&#xA;那如果要遍历的话&#xA;只能是短的一边进行更新，如果是左边的指针那就往右移动&#xA;如果是右边的就往左边进行移动&#xA;也就是都向&amp;quot;中间&amp;quot;更新&#xA;因为在横坐标两条垂线的距离降低的情况下，如果变化的是长边，盛水的长方形的高依旧不会变，不需要比较，那么面积必然会更小&#xA;第三步 那迭代出来的面积个数不止一个，怎么办呢？&#xA;分别比大小就可以了&#xA;第三步的步骤就是把每次迭代出来的值与之前的最大值比大小&#xA;如果更新的值更大，那就更新最大值就行&#xA;代码具体实现 注意 这里是展示所有代码可直接运行，但是力扣上的一个类，所以要改一下才可以跑</description>
    </item>
    <item>
      <title>用python从零开始做一个最简单的小说爬虫带GUI界面（1/3)</title>
      <link>https://0ha.top/posts/132394257/</link>
      <pubDate>Thu, 24 Aug 2023 04:27:29 +0000</pubDate>
      <guid>https://0ha.top/posts/132394257/</guid>
      <description>目录&#xA;下一章内容&#xA;PyQt5的配置&#xA;设置软件的快捷启动方式&#xA;1. 用于设计界面的程序&#xA;2. 将Qt Designer设计出来的ui文件转化为py文件&#xA;3. 可以把py文件打包成可执行的exe文件&#xA;4. 将ico图片放在qrc文件中，再将qrc文件转换成py文件，用于小工具的图标&#xA;快捷使用方法&#xA;设计界面&#xA;把设计的ui界面的ui文件转为py文件&#xA;main文件中的代码&#xA;下一章内容 用python从零开始做一个最简单的小说爬虫带GUI界面（2/3）_木木em哈哈的博客-CSDN博客前一章博客我们讲了怎么通过PyQt5来制作图形化界面，并且进行一些基本设置接下来两章我们主要讲核心爬虫代码的实现。https://blog.csdn.net/mumuemhaha/article/details/132457770?spm=1001.2014.3001.5501 ;&#xA;PyQt5的配置 配置其他的博主上有教程&#xA;建议安装以下包（最好在你原来的电脑环境也就是你电脑的cmd中输入以下命令，不要在pycharm创建的虚拟环境下创建，防止项目删除后软件打不开）&#xA;pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple PyQt5 pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple PyQt5-tools pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple paramiko pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pyinstaller 当然在pycharm中也要安装一遍&#xA;之后在设置中&#xA;选择工具-&amp;gt;外部工具-&amp;gt;加号&#xA;设置软件的快捷启动方式 然后依次新建如下内容&#xA;1. 用于设计界面的程序 名称：Qt Designer 工具设置 程序：C:\Users\你的用户名\AppData\Local\Programs\Python\你的python版本\Lib\site-packages\qt5_applications\Qt\bin\designer.exe 工作目录：$FileDir$ 2. 将Qt Designer设计出来的ui文件转化为py文件 名称：PyUIC 工具设置： 程序：C:\Users\你的用户名\AppData\Local\Programs\Python\你的python版本\Scripts\pyuic5.exe 实参：$FileName$ -o $FileNameWithoutExtension$.py 工具目录：$FileDir$ 3. 可以把py文件打包成可执行的exe文件 名称：PyInstall 工具设置： 程序：C:\Users\你的用户名\AppData\Local\Programs\Python\你的python版本\Scripts\pyinstaller.exe 实参： -F -w $FileNameWithoutExtension$.</description>
    </item>
    <item>
      <title>用python从零开始做一个最简单的小说爬虫带GUI界面（2/3）</title>
      <link>https://0ha.top/posts/132457770/</link>
      <pubDate>Thu, 24 Aug 2023 03:30:46 +0000</pubDate>
      <guid>https://0ha.top/posts/132457770/</guid>
      <description>目录&#xA;前一章博客&#xA;前言&#xA;主函数的代码实现&#xA;逐行代码解析&#xA;获取链接&#xA;获取标题&#xA;获取网页源代码&#xA;获取各个文章的链接&#xA;函数的代码&#xA;导入库文件&#xA;获取文章的标题&#xA;获取文章的源代码&#xA;提取文章目录的各个文章的链接&#xA;总代码&#xA;下一章内容&#xA;前一章博客 用python从零开始做一个最简单的小说爬虫带GUI界面（1/3)_木木em哈哈的博客-CSDN博客而且当时的爬虫代码有许多问题但是最近学了PyQt5想着搞个带界面的爬虫玩玩那就啥也不说开搞！！！https://blog.csdn.net/mumuemhaha/article/details/132394257?spm=1001.2014.3001.5501 ;&#xA;前言 前一章博客我们讲了怎么通过PyQt5来制作图形化界面，并且进行一些基本设置&#xA;接下来两章我们主要讲核心爬虫代码的实现&#xA;主函数的代码实现 前一章中的代码&#xA;self.Button_run.clicked.connect(self.F_run) 代表点击按钮执行F_run函数（注意这里不要打括号）&#xA;那么我们就需要定义这个函数&#xA;思路大概就是这样&#xA;def F_run(self): link_1=self.line_link.text() title_1=F_gettitle(link_1) self.text_result.setText(f&amp;#34;标题获取成功——{title_1}&amp;#34;) # file_1=open(f&amp;#39;{title_1}.txt&amp;#39;,mode=&amp;#39;w&amp;#39;,encoding=&amp;#39;utf-8 &amp;#39;) test_1=F_getyuan(link_1) self.text_result.setText(&amp;#34;提取源代码成功&amp;#34;) time.sleep(1) search_1=F_searchlink(test_1) self.text_result.append(&amp;#34;提取文章链接成功&amp;#34;) pachong(search_1,title_1) 逐行代码解析 获取链接 首先通过&#xA;self.line_link.text() 命令获取在输入框中输入的链接&#xA;并且把它赋值到link_1中&#xA;获取标题 同时我会通过爬取网页链接的源代码进行提取关键字获得文章的标题&#xA;也就是小说的名字&#xA;title_1=F_gettitle(link_1) 获取网页源代码 爬取小说文章目录网页的源代码并且赋值为test_1（用于后续提取各个文章的链接）&#xA;test_1=F_getyuan(link_1) 获取各个文章的链接 search_1=F_searchlink(test_1) 把得到的源代码进行提取筛选获得各个文章的链接&#xA;其中self.text_result.setText以及self.text_result.append是在下面红圈中显示的东西&#xA;（美观用，可以不加）&#xA;函数的代码 这里为了不让代码过于长，我自己有单独新建了两个python文件用于存放python函数&#xA;导入库文件 import requests import re import numpy as np from lxml import etree request用于网络请求</description>
    </item>
    <item>
      <title>用python来爬取某鱼的商品信息（2/2）</title>
      <link>https://0ha.top/posts/132260466/</link>
      <pubDate>Sun, 13 Aug 2023 09:05:51 +0000</pubDate>
      <guid>https://0ha.top/posts/132260466/</guid>
      <description>目录&#xA;上一篇文章&#xA;本章内容&#xA;设置浏览器为运行结束后不关闭（可选）&#xA;定位到搜索框的xpath地址&#xA;执行动作&#xA;获取cookie&#xA;保存为json文件&#xA;修改cookie的sameSite值并且导入cookie&#xA;导入cookie（出错）&#xA;导入cookie（修改后）&#xA;最后出现页面&#xA;需要注意的问题&#xA;所有代码&#xA;总结&#xA;上一篇文章 用python来爬取某鱼的商品信息（1/2）_木木em哈哈的博客-CSDN博客本章讲理论，后面一节讲代码拿来练练手的，练练selenium包，实战一下（本来想拿来练手的，没想到他喵的有挺多防爬的，直接开局就困难难度我靠，凸(艹皿艹 )）找到可以爬取的网站然后添加cookie然后刷新界面就可以发现搜索结果出来了这一次实战经历真的让我遇到了selenium许多奇奇怪怪的反爬手段，也是让我可以大幅度提升自己实战经验的一个经历，前前后后排bug，绕反爬，这一个项目打了整整两天。累diet https://blog.csdn.net/mumuemhaha/article/details/132238660?spm=1001.2014.3001.5502 ;&#xA;本章内容 主要讲的是上一章的代码实现&#xA;导入所需要的程序包&#xA;from selenium import webdriver from selenium.webdriver import ActionChains from selenium.webdriver.common.keys import Keys import time import json 设置浏览器为运行结束后不关闭（可选） 之后先设置自己想要搜索的内容，并且把浏览器设置为允许结束后不关闭，并且打开要爬取的咸鱼网站（可设可不设）&#xA;input_1=input(&amp;#39;输入想要搜索的内容:&amp;#39;) option = webdriver.ChromeOptions() option.add_experimental_option(&amp;#34;detach&amp;#34;, True) # 注意此处添加了chrome_options参数 driver = webdriver.Chrome(chrome_options=option) driver.get(&amp;#39;https://h5.m.goofish.com/app/idleFish-F2e/fish-mini-pha/search.html?spm=a2170.tb_mini_index.0.0&amp;#39;) 定位到搜索框的xpath地址 driver_1=driver.find_element(by=&amp;#39;xpath&amp;#39;,value=&amp;#39;/html/body/div/div/div[1]/input&amp;#39;) 执行动作 执行动作（调用鼠标api点击刚刚定位的搜索框，然后输入input_1的值并且回车&#xA;ActionChains(driver) \ .move_to_element(driver_1) \ .click_and_hold() \ .pause(1) \ .send_keys(input_1) \ .key_down(Keys.ENTER)\ .perform() time.sleep(1) 中间的.</description>
    </item>
    <item>
      <title>用python来爬取某鱼的商品信息（1/2）</title>
      <link>https://0ha.top/posts/132238660/</link>
      <pubDate>Sun, 13 Aug 2023 08:58:53 +0000</pubDate>
      <guid>https://0ha.top/posts/132238660/</guid>
      <description>目录&#xA;前言&#xA;第一大难题——找到网站入口&#xA;曲线救国&#xA;模拟搜索&#xA;第二大难题——登录&#xA;提一嘴&#xA;登录cookie获取&#xA;第一种&#xA;第二种&#xA;第四大难题——无法使用导出的cookie&#xA;原因&#xA;解决办法&#xA;最后&#xA;出现小问题&#xA;总结&#xA;下一篇博客（大部分代码实现）&#xA;前言 本章讲理论，后面一节讲代码&#xA;拿来练练手的，练练selenium包，实战一下&#xA;（本来想拿来练手的，没想到他喵的有挺多防爬的，直接开局就困难难度我靠，凸(艹皿艹 )）&#xA;找到可以爬取的网站&#xA;第一大难题——找到网站入口 但是咸鱼官方的网站已经关闭了（开局就不利）&#xA;闲鱼.淘宝二手 - 轻松卖闲置，放心淘二手闲鱼.淘宝二手是一个社区化的二手闲置交易市场，不仅支持各种同城及线上的担保交易，更安全，同时还有最专业的放心购二手商家，让你轻松在这买卖二手闲置。https://goofish.com/;&#xA;GG&#xA;曲线救国 但是后面发现可以通过淘宝手机版网页版的入口直接进入咸鱼网页版的入口（反正都是爬取怎么进的不重要啦！！！）&#xA;链接放着里了，怎么进别问我了&#xA;淘宝淘宝网 - 亚洲较大的网上交易平台，提供各类服饰、美容、家居、数码、话费/点卡充值&amp;hellip; 数亿优质商品，同时提供担保交易(先收货后付款)等安全交易保障服务，并由商家提供退货承诺、破损补寄等消费者保障服务，让你安心享受网上购物乐趣！https://main.m.taobao.com/index.html ;&#xA;好了第一大难题（找到网页版入口解决了）&#xA;模拟搜索 接下来就是利用python的selenium包模拟点击&#xA;右键搜索款点击检查就可以定位到该元素的xpath的路径（ 新版的selenium有许多不同的用法我会在下一章中进行代码实现，这一章主要讲解理论）&#xA;然后在python代码中输入你要搜索的文字内容再回车即可&#xA;第二大难题——登录 在这一个咸鱼网页版中，你必须要登录才可以&#xA;这样你就要先登录才可以访问网页&#xA;最大难题——登录界面滑块验证&#xA;提一嘴 在这个登录页面中，登录页面是iframe内嵌入其中的页面的&#xA;所以你无法直接定位到登录框（我搞了好久反应过来，真的离谱！！）&#xA;登录cookie获取 所以你有两种选择&#xA;第一种 直接在python中打开登录页面进入登录页面然后登录直接用selenium库中的get_cookie获取cookie并保存&#xA;登录https://passport.goofish.com/mini_login.htm?ttid=h5%40iframe&amp;amp;redirectType=iframeRedirect&amp;amp;returnUrl=%2F%2Fh5.m.goofish.com%2Fapp%2Fvip%2Fh5-webapp%2Flib-login-message.html%3Forigin%3Dhttps%253A%252F%252Fh5.m.goofish.com&amp;amp;appName=xianyu&amp;amp;appEntrance=web&amp;amp;isMobile=true ;想法相对来说不这么绕，但是遗憾的是我无法登录（因为登录有滑块验证，我是几乎过不了的，手动都不行）&#xA;第二种 在正常网页中登入之后用浏览器插件提取出来&#xA;我用的是cookie editor&#xA;在网页版中正常登录可以过滑块验证&#xA;之后用插件复制出json文件，并且进行粘贴&#xA;第四大难题——无法使用导出的cookie 使用代码导入是报错&#xA;assert cookie_dict[&amp;#39;sameSite&amp;#39;] in [&amp;#39;Strict&amp;#39;, &amp;#39;Lax&amp;#39;] AssertionError() 原因 提取出来的cookie中samesite的值不为strict以及lax两种中的一种，他就会报错</description>
    </item>
    <item>
      <title>2022蓝桥杯题目——“山”</title>
      <link>https://0ha.top/posts/132124484/</link>
      <pubDate>Sat, 05 Aug 2023 13:22:18 +0000</pubDate>
      <guid>https://0ha.top/posts/132124484/</guid>
      <description>暴力解法&#xA;中间一部分&#xA;末尾一部分&#xA;开头一部分&#xA;代码部分讲解&#xA;最终所有代码&#xA;这天小明正在学数数。 他突然发现有些正整数的形状像一挫 &amp;ldquo;山&amp;rdquo;, 比如 123565321、145541123565321它 们左右对称 (回文) 且数位上的数字先单调不减, 后单调不增。 小朋数了衣久也没有数完, 他惒让你告诉他在区间 [2022,2022222022] 中有 多少个数的形状像一座 &amp;ldquo;山&amp;rdquo;。&#xA;填空题，要写出答案即可&#xA;思路非常简单，提取每一个数字的位数来判断两边是否相等，并且判断前一半是否是单调不减的&#xA;缺点是每一个都要计算会十分麻烦，计算量直接来到了10的10次方，估计要运行一分多钟，虽然题目只要求答案，你可以运行完成后直接打印答案，但是还有更加巧妙的思路&#xA;由于1111~999999999可以进行变化&#xA;取前一半数字，只要他满足单调不减就行了&#xA;比如如果五位数&#xA;取前一半也就是三个数字&#xA;124时，后面必定有且只有一种数字（21）与其对应，形成12421&#xA;所以我们只需算前一半的数字即可&#xA;也就是11~99999&#xA;这一个变化带来速度提升是巨大的&#xA;时间直接缩小几个数量级&#xA;在末尾中2022222022这个数字比较特殊&#xA;因为开头为2所以前一位也必须不比2小的数&#xA;显然2后面是0无法满足条件&#xA;所以最高位2必须要变小，然而不能为0&#xA;所以只能是1（个位同时也必须是1），而且中间部分位数可以随便变化（因为1111111111~1999999991属于2022~2022222022）&#xA;于是可以把他看成为8位数字，然后再算一次加起来就行了&#xA;开头没什么好说的&#xA;2022~9999&#xA;提取前一半位数，同时由于最小为2，所以百位也必须是不比2小的数字（2,3,4,5,6,7,8,9）&#xA;以此类推可以心算出来开头部分（2022~9999）的符合条件的个数为8+7+6+5+4+3+2+1&#xA;最后全部加起来&#xA;代码部分讲解 中间一部分加末尾一部分为&#xA;int sum_2 = 0; int sum_3 = 0; int sum_4 = 0; if (i == 10) //同时1111111111-2022222022的情况与111111111-99999999一致 sum_2 = 9 / 2; else if (i % 2 == 0) sum_2 = i / 2; else sum_2 = i / 2+1; for (int j = 0; j 由于奇数位数的数字取一半用的是进一法，而c/c++用的是退一法，所以对奇数位数的数字做出分类以及改变</description>
    </item>
    <item>
      <title>2019蓝桥杯省赛题目——“数的分解”</title>
      <link>https://0ha.top/posts/132119564/</link>
      <pubDate>Sat, 05 Aug 2023 12:54:33 +0000</pubDate>
      <guid>https://0ha.top/posts/132119564/</guid>
      <description>最后的代码&#xA;把 2019 分解成 3 个各不相同的正整数之和，并且要求每个正整数都不包含数字 2 和 4，一共有多少种不同的分解方法？ 注意交换 3 个整数的顺序被视为同一种方法，例如 1000+1001+18 和 1001+1000+18 被视为同一种。&#xA;这是一道结果填空的题，你只需要算出结果后提交即可&#xA;思路很简单——穷举每一个数字&#xA;每个正整数都不包含数字 2 和 4就把各个位数的千位百位十位各位提取出来分别判断&#xA;bool Panduan(int n) { int a = n / 1000; int b = (n - a * 1000) / 100; int c = (n - a * 1000 - b * 100) / 10; int d = n % 10; if (a == 2 || a == 4 || b == 2 || b == 4 || c == 2 || c == 4 || d == 2 || d == 4) { return false; } else { return true; } } 关于筛选只是顺序不同的数字可以固定大小比如三个数字x,y,z固定x&amp;gt;y&amp;gt;z这样就不会因为顺序不一样，造成多算出来结果</description>
    </item>
    <item>
      <title>C&#43;&#43;智能指针（3/3）</title>
      <link>https://0ha.top/posts/131743884/</link>
      <pubDate>Sat, 15 Jul 2023 15:14:35 +0000</pubDate>
      <guid>https://0ha.top/posts/131743884/</guid>
      <description>目录&#xA;上一节内容&#xA;例子（类定义）&#xA;主函数代码&#xA;执行的结果&#xA;解释说明&#xA;赋值&#xA;主动释放&#xA;重置指针&#xA;交换指针的值&#xA;原因&#xA;解决办法之一&#xA;weak_ptr智能指针（弱指针）&#xA;weak智能指针的用法&#xA;注意&#xA;弱指针到共享指针的转化&#xA;特别感谢&#xA;上一节内容 C++智能指针（2/3）_木木em哈哈的博客-CSDN博客自动释放内存：智能指针使用了RAII（资源获取即初始化）的原则，在创建时分配内存，在销毁时自动释放内存，无需手动管理内存释放，避免了因为忘记释放内存而造成的内存泄漏问题。unique_ptr是一种独占所有权的智能指针，同一时间只能有一个unique_ptr指向一个对象，当unique_ptr被销毁时，对象也会被释放。在这之中开始时p1托管str的指针，后面p2接管str指针的同时会把p1的托管给取消，这样p1指针指向的就是NULL（空），从而报错。这是因为auto_ptr与unique_ptr的排他性。https://blog.csdn.net/mumuemhaha/article/details/131689322?spm=1001.2014.3001.5502 ;这一节我们来学最后的share_ptr和weak_ptr&#xA;shared_ptr使用引用计数的方式来管理资源，即每个shared_ptr对象都有一个关联的计数器，记录有多少个shared_ptr对象共享同一块内存资源。当计数器为0时，资源会被自动释放。&#xA;当复制或拷贝时， 引用计数加1，当智能指针析构时， 引用计数减1，如果计数为零，代表已经没有指针指向这块内存，那么我们就释放它！这就是 shared_ptr 采用的策略！&#xA;例子（类定义） class Person { public: Person(int v) { this-&amp;gt;no = v; cout &amp;lt;&amp;lt; &amp;#34;构造函数 \t no = &amp;#34; &amp;lt;&amp;lt; this-&amp;gt;no &amp;lt;&amp;lt; endl; } ~Person() { cout &amp;lt;&amp;lt; &amp;#34;析构函数 \t no = &amp;#34; &amp;lt;&amp;lt; this-&amp;gt;no &amp;lt;&amp;lt; endl; } private: int no; }; 主函数代码 int main() { //定义两个share指针同时第二个由于已经构造好了，引用次数+1 shared_ptr sp1; shared_ptr sp2(new Person(2)); // 获取智能指针管控的共享指针的数量&#x9;use_count()：引用计数 cout &amp;lt;&amp;lt; &amp;#34;sp1引用计数 = &amp;#34; &amp;lt;&amp;lt; sp1.</description>
    </item>
    <item>
      <title>C&#43;&#43;的智能指针（1/3）</title>
      <link>https://0ha.top/posts/131668974/</link>
      <pubDate>Sat, 15 Jul 2023 12:42:01 +0000</pubDate>
      <guid>https://0ha.top/posts/131668974/</guid>
      <description>为什么要使用智能指针&#xA;智能指针的作用&#xA;举个例子&#xA;最开始使用的智能指针——auto_ptr&#xA;使用方法&#xA;举个例子&#xA;进阶使用&#xA;这时候的调用结果&#xA;对比使用智能指针&#xA;调用函数方法&#xA;智能指针常用的是三个函数&#xA;get() 返回智能指针托管的指针地址&#xA;release() 取消智能指针对动态内存的托管&#xA;reset() 重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉&#xA;注意事项&#xA;auto_ptr的缺点以及为什么在C++11中被淘汰&#xA;下一节&#xA;参考文章（感谢大佬）&#xA;为什么要使用智能指针 使用智能指针的主要目的是管理动态分配的内存，以确保在不再需要时正确释放内存，避免内存泄漏和悬挂指针等问题。&#xA;智能指针的作用 智能指针是一种封装了原始指针的对象，它提供了自动内存管理的功能。与传统的裸指针相比，智能指针具有以下优势：&#xA;自动释放内存：智能指针使用了RAII（资源获取即初始化）的原则，在创建时分配内存，在销毁时自动释放内存，无需手动管理内存释放，避免了因为忘记释放内存而造成的内存泄漏问题。 避免悬挂指针：智能指针会在其所管理的对象不再需要时自动释放内存，并将指针置为空，避免了悬挂指针问题，即指向已经释放的内存区域。 异常安全：智能指针可以确保在发生异常时正确释放资源，因为它们的析构函数会在对象被销毁时自动调用。 方便易用：智能指针提供了类似于原始指针的操作符重载，使得使用起来更加方便和直观。 总之，使用智能指针可以提高代码的可靠性和安全性，并减少手动管理内存的工作量，是现代C++编程中推荐的做法。&#xA;#include #include #include using namespace std; void Function_1() { int *a=new int; *a = 12; //省略其他代码 if (true) { return; //此时已经跳出循环所以不执行下面的删除指针a } delete a; } int main() { Function_1(); //这时a指针没有被释放 return 0; } 这个时候在执行程序的这一过程中a指针没有被及时释放，这只是一个简单的例子，&#xA;在真实的情况中也不会只有这一个a没有被释放，甚至在一些循环中如果释放指针那造成的结果是灾难性的，你排除一些报错会十分的困难。&#xA;每次记住及时释放指针是一个好习惯并且也是一个好的解决办法。但是这是十分困难的&#xA;这个时候就可以使用智能指针这个方案&#xA;最开始使用的智能指针——auto_ptr auto_ptr 是c++ 98定义的智能指针模板，其定义了管理指针的对象，可以将new 获得（直接或间接）的地址赋给这种对象。当对象过期时，其析构函数将使用delete 来释放内存！</description>
    </item>
    <item>
      <title>用python爬取博客的图片链接（入个门）</title>
      <link>https://0ha.top/posts/131056725/</link>
      <pubDate>Thu, 13 Jul 2023 02:12:41 +0000</pubDate>
      <guid>https://0ha.top/posts/131056725/</guid>
      <description>目录&#xA;前言&#xA;请求网页的源代码&#xA;定义头文件&#xA;爬取源代码&#xA;开始选取所需要的部分&#xA;用PyQuery选择相应的区块（分支可看可不看）&#xA;优点&#xA;缺点&#xA;开始定位链接的位置（使用正则表达式）&#xA;出现的奇怪的问题&#xA;前言 学了一个晚上学了一点点皮毛可能还有很多地方有不足但是思想大概搞懂了（python的re库把我脑袋搞晕了QAQ）&#xA;这个大佬轻喷，有什么改进可以指出十分感谢&#xA;请求网页的源代码 定义头文件 许多网站为了防止有人恶意爬取，网站就会做反爬取&#xA;这个时候就要自己定义头文件，以便于可以正常显示源代码&#xA;比如csdn不定义User-Agent返回的源代码就为空&#xA;按f12打开控制台，打开网络（network）刷新网页，随便点击一个链接在请求的文件里有&#xA;一般用到的就是User-Agent，host,cookie，Accept和connection&#xA;这边我就定义一个头文件变量&#xA;headers_dict={ &amp;#39;User-Agent&amp;#39;:&amp;#39;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Mobile Safari/537.36 Edg/114.0.1823.37&amp;#39; } 爬取源代码 然后开始爬取网页源代码&#xA;并且把源代码存起来&#xA;response = requests.get(&amp;#39;https://blog.csdn.net/mumuemhaha/article/details/131031052?spm=1001.2014.3001.5501&amp;#39;,headers=headers_dict) html_1=response.text 开始选取所需要的部分 用PyQuery选择相应的区块（分支可看可不看） PyQuery可以把源代码中的&amp;hellip;和，的部分筛选出来 可以用 doc = pq(html) print(doc(&amp;rsquo;.a_1 #b_1&amp;rsquo;).find(&amp;ldquo;c_1&amp;rdquo;)) 其中a_1代表的就是.（英文句号）+div class=&amp;quot; &amp;ldquo;空的值 b_1代表的就是ul id = &amp;quot; &amp;ldquo;空的值 c_1代表得到就是两个标签名称上面就&amp;rdquo;&#xA;&amp;quot; 优点 是语法相对比较简单&#xA;可以快速选择所需要的区域&#xA;缺点 只凭这个无法定位标签栏里面的元素，尤其是图片链接</description>
    </item>
    <item>
      <title>玩客云安装好armbian5.9后后续安装宝塔7.x版本</title>
      <link>https://0ha.top/posts/130301456/</link>
      <pubDate>Thu, 13 Jul 2023 02:10:26 +0000</pubDate>
      <guid>https://0ha.top/posts/130301456/</guid>
      <description>目录&#xA;前言&#xA;下载脚本&#xA;可能得报错以及解决办法&#xA;替换官方源&#xA;修改区时间&#xA;接下的步骤&#xA;全修复脚本&#xA;前言 在通过烧录u盘安装好armbian后如果新手要搭建网站的话就要安装宝塔面板了&#xA;但是因为armbian版本是32位的，因为CPU是s805是32位的，虽然可以安装宝塔最后一个32位的5.9的版本，但是有很多的配置如Nginx好像安装失败&#xA;下载脚本 而常规去官网上下载安装脚本就会出错&#xA;所以就要改一下官网下载的脚本这里下载链接下载&#xA;下好后用xftp来链接你本地的ip地址然后传输到/root目录下（也可以传输到其他目录，方便起见还是传到/root）&#xA;可能得报错以及解决办法 可能会提示无法访问从xftp中打开xshell&#xA;输入sudo -i，然后输入你的root密码&#xA;再输入&#xA;chmod 777 /root 给予访问/root的权限&#xA;就可以访问/root文件夹了&#xA;然后在此之前还要配置一下其他的文件&#xA;替换官方源 打开源文件替换源&#xA;nano /etc/apt/sources.list nano没安装的去安装&#xA;deb https://mirrors.ustc.edu.cn/debian buster main contrib non-free&#xD;deb https://mirrors.ustc.edu.cn/debian buster-updates main contrib non-free&#xD;deb https://mirrors.ustc.edu.cn/debian buster-backports main contrib non-free&#xD;deb https://mirrors.ustc.edu.cn/debian-security/ buster/updates main contribnon-free 修改区时间 之后修改区时间&#xA;nano /etc/apt/sources.list.d/raspi.list deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui&#xD;deb-src http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/buster main ui 更新一下&#xA;apt-get update 好了之后直接执行安装脚本</description>
    </item>
    <item>
      <title>C&#43;&#43;智能指针（2/3）</title>
      <link>https://0ha.top/posts/131689322/</link>
      <pubDate>Thu, 13 Jul 2023 02:03:55 +0000</pubDate>
      <guid>https://0ha.top/posts/131689322/</guid>
      <description>上一章节内容&#xA;unique_ptr指针&#xA;unique的特点&#xA;容器中&#xA;构造，赋值，释放&#xA;auto_ptr以及unique_ptr的排他性&#xA;特别感谢&#xA;上一章节内容 unique_ptr指针 开门见山&#xA;这一章节我们来了解unique指针&#xA;什么是unique_ptr指针&#xA;unique_ptr是一种独占所有权的智能指针，同一时间只能有一个unique_ptr指向一个对象，当unique_ptr被销毁时，对象也会被释放。unique_ptr不能被复制，只能通过移动语义转移所有权。&#xA;#include #include #include using namespace std; int main() { unique_ptr p1(new string(&amp;#34;hello&amp;#34;)); unique_ptr p2(new string(&amp;#34;hi&amp;#34;)); cout &amp;lt;&amp;lt; &amp;#34;p1：&amp;#34; &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;p2：&amp;#34; &amp;lt;&amp;lt; p2.get() &amp;lt;&amp;lt; endl; //p1 = p2;&#x9;// 禁止左值赋值 //unique_ptr p3(p2);&#x9;// 禁止左值赋值构造 unique_ptr p3(std::move(p1)); p1 = std::move(p2);&#x9;// 使用move把左值转成右值就可以赋值了 cout &amp;lt;&amp;lt; &amp;#34;p1 = p2 赋值后：&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;p1：&amp;#34; &amp;lt;&amp;lt; p1.</description>
    </item>
    <item>
      <title>光猫拨号有公网ipv6但是路由器没有下发ipv6的功能怎么办</title>
      <link>https://0ha.top/posts/131504367/</link>
      <pubDate>Sun, 02 Jul 2023 11:50:57 +0000</pubDate>
      <guid>https://0ha.top/posts/131504367/</guid>
      <description>目录&#xA;起因&#xA;操作&#xA;第一&#xA;第二&#xA;第三&#xA;第四&#xA;第五（最重要的一步）&#xA;最后一步&#xA;起因 因为家里的路由器没有ipv6；但是当我连接光猫的时候，我发现我居然有ipv6的公网。&#xA;然后我在路由器上找开启ipv6的选项，遗憾的是我没有找到&#xA;操作 第一 连接光猫的wifi或者连接光猫的网口，在cmd中输入ipconfig（linux输入ifconfig）&#xA;查看默认网关&#xA;第二 连接路由器的wifi并且同样的方法查看默认网关&#xA;第三 在浏览器中输入该路由器的网关地址&#xA;然后调整ip地址&#xA;把他的地址调整到光猫的ip网关地址&#xA;子网掩码不变&#xA;点击提交&#xA;第四 在地址栏输入刚刚改的ip网关地址&#xA;把DHCP服务关掉（现在就由路由器分配内网ipv4以及公网ipv6地址）&#xA;第五（最重要的一步） 把光猫的网口接到路由器的lan口上（注意是lan口而不是wan口，就是很多个一起的）&#xA;最后一步 重启路由器过五分钟，就可以看到自己有ipv6的地址了</description>
    </item>
    <item>
      <title>本地路由器封80与443但是可以用端口映射，所以用宝塔创建指定端口的网站</title>
      <link>https://0ha.top/posts/130423372/</link>
      <pubDate>Wed, 21 Jun 2023 13:44:45 +0000</pubDate>
      <guid>https://0ha.top/posts/130423372/</guid>
      <description>目录&#xA;前因&#xA;错误&#xA;原因思考&#xA;教程&#xA;设置路由器端口映射&#xA;注意&#xA;前因 前几天发过一个博客上一个链接https://blog.csdn.net/mumuemhaha/article/details/130284390?spm=1001.2014.3001.5501 ;&#xA;错误 讲了80和443端口被封的问题&#xA;当时以为没有别的办法了，结果最近仔细一想&#xA;发现我指定端口访问不就行了&#xA;但是我宝塔添加站点的时候添加指定端口依旧无法从外网访问，然后我开始研究原因&#xA;我把原来的的80端口的给删除了创建了一个用8848的端口访问的网站&#xA;然后用我本机的ip（192.168.0.173）加8848访问&#xA;成功！ 然后我依旧在内网用公网ip加8848端口访问&#xA;成功！ 用外网时访问&#xA;失败！&#xA;原因思考 很奇怪我明明设置了8848端口而且我搭建的青龙和宝塔都可以外网访问&#xA;然后我开始找原因：&#xA;这一会我什么端口都不指定直接用192.168.0.173进行访问&#xA;也成功了说明他现在用的是80端口，但是我没有添加80端口的域名&#xA;然后我猜测用其他端口访问，其实最终也是跳转到80端口的（然而外网80端口被封了导致访问不了）&#xA;那怎么整呢？&#xA;教程 上教程&#xA;打开配置文件&#xA;这个我已经改过了&#xA;原来是这个&#xA;listen 80;&#xD;server_name xxxx; 抱着试一试的心里&#xA;我把80端口改为5960端口&#xA;然后用本地ip地址访问&#xA;啊？不行，是不是没重启nginx&#xA;重启后&#xA;ok,跳转到我搭建的博客了&#xA;然后接下来就简单了&#xA;设置路由器端口映射 设置dmz主机或者端口映射（本地5960，外网5960）&#xA;就可以从外网通过ip访问了&#xA;如果 要绑定域名的话比较就要用ipv4解析然后加端口号&#xA;但是如果要图一个简单的话直接输入域名就可以访问的话&#xA;还可以设置解析到指定端口&#xA;或者设置url跳转&#xA;当然前提是域名还需要备案（为了防止做违法的事）&#xA;如果出什么问题或者留个言，解析到指定端口教程估计过几天做，现在备案不了，现在身份证不在旁边。&#xA;注意 由于浏览器有缓存所以有时不成功记得把浏览器缓存给清理之后再次浏览</description>
    </item>
    <item>
      <title>什么是docker以及一些有趣的docker项目</title>
      <link>https://0ha.top/posts/131325482/</link>
      <pubDate>Wed, 21 Jun 2023 10:03:27 +0000</pubDate>
      <guid>https://0ha.top/posts/131325482/</guid>
      <description>docker的介绍&#xA;什么是docker&#xA;那为什么我们要用docker而不用虚拟机呢？&#xA;启动优势&#xA;docker资源消耗会更少&#xA;docker具有一键部署的简便性&#xA;docker的卸载简便性&#xA;docker的可移植性&#xA;docker相比于虚拟机的局限性&#xA;docker的隔离性不如虚拟机&#xA;docker的安全性不如虚拟机&#xA;部分docker项目的介绍&#xA;alist&#xA;部署命令&#xA;nextcloud&#xA;部署命令&#xA;青龙面板&#xA;部署命令&#xA;网心云&#xA;部署命令&#xA;kodbox（可道云）&#xA;部署命令&#xA;部署命令&#xA;docker的介绍 Docker是基于linux内核的一个自由开发，打包，运行程序的平台，Dcoker可以让我们将程序从环境中分离出来从而实现快速迁移我们的项目。通过Docker，管理我们的应用就像管理我们的环境一样简单（我觉得在实际开发中哪个都不简单，对于刚毕业的我来说），通过利用docker技术可以快速打包，测试，部署我们的代码，你可以显著的减少在编写代码以及将它运行在生产环境中的时间损耗。&#xA;他是真正让我意识到linux方便之处的开始&#xA;简单狭义的来说docker就是一个轻量的虚拟机&#xA;docker的启动速度方面要比虚拟机快的多得多&#xA;docker在操作系统级别进⾏虚拟化，他与硬件内核的交互利用率几乎是100%&#xA;而Hypervisor层与内核层的虚拟化有时只能达到50%&#xA;大多数的docker项目只需要一段命令就可以完美安装好他人提供的镜像&#xA;无需再次安装其他依赖&#xA;相比于把一堆垃圾软件安装到系统上然后难以删除（尤其是linux系统）&#xA;docker就是一种十分简单的安装与卸载的形式&#xA;你不仅可以下载别人的镜像与此同时，你也可以发布你自己做好的镜像以供他人使用。&#xA;他人也可以用几段代码拉取你制作的镜像&#xA;与系统隔离的虚拟机相比，docker只是进程间的隔离。&#xA;由于docker的隔离性不行，所以当他测试一些恶意软件时他的安全性不如虚拟机&#xA;部分docker项目的介绍 这一个项目可以挂载市面上几乎任何的网盘（百度云盘，阿里云盘，123云盘&amp;hellip;）&#xA;并且可以通过webdav来挂载阿里云视频到本地文件夹，之后通过emby来实现播放搭建自己的私人影院&#xA;或者你也可以配合aria2来实现获取网盘文件的快速下载链接，比如阿里云盘在我电脑上用客户端下载时10m/s而用aria2可以实现30m/s 的下载速度&#xA;docker run -d --restart=always -v 你缓存的文件夹位置:/opt/alist/data -p 5244:5244 --name=&amp;#34;alist&amp;#34; xhofe/alist:latest 运行下面命令获得密码&#xA;docker exec -it alist ./alist admin 网站在服务器ip:5244&#xA;它是一个私人云盘服务，并且可以提供下载上传以及挂载等多方面的功能（PS：私人云盘如果在内网搭建的话，网口配置只要不要太烂，内网之间的传输速率是非常非常快的，我这边是60m/s，并且不占用局域网内其他电脑的宽带）&#xA;docker run -d --restart=always --name nextcloud -p 80:80 -v /root/nextcloud:/data rootlogin/nextcloud 网站在服务器ip:80</description>
    </item>
    <item>
      <title>如何查看自己的ssh端口是否被攻击</title>
      <link>https://0ha.top/posts/131324962/</link>
      <pubDate>Wed, 21 Jun 2023 05:19:27 +0000</pubDate>
      <guid>https://0ha.top/posts/131324962/</guid>
      <description>目录&#xA;环境&#xA;起因&#xA;查看ssh日志&#xA;用命令直接查看&#xA;解决办法&#xA;关闭ssh密码登录启用秘钥登录&#xA;缺点&#xA;改端口（推荐）&#xA;ip黑名单（个人用户不推荐）&#xA;缺点&#xA;验证/其他的一些命令&#xA;查询ip地址的最后登入时间&#xA;查询ip地址的开始登入时间&#xA;查询恶意ip登入失败时最常用的账号名称&#xA;环境 debian 11_64 宝塔面板 起因 之前在进入宝塔后台的时候发现一个惊讶的点&#xA;我的ssh端口好像一直被别人用弱密码爆破&#xA;虽然密码设计的很复杂&#xA;但是每次看到这个东西一天加个几千次失败有些看不顺眼&#xA;查看ssh日志 不知道为什么我安装网上的教程来做&#xA;当我输入&#xA;cat /var/log/auth.log | grep &amp;#34;Failed password&amp;#34; 时它什么也不显示，好像我本来没有这个文件&#xA;看到一些开启日志的解决方法，但是我也懒得搞了&#xA;用命令直接查看 于是我直接用命令进行查看&#xA;lastb | awk &amp;#39;{ print $3}&amp;#39; | sort | uniq -c | sort -n 109 113.140.8.194 109 45.95.147.218 113 185.224.128.141 118 185.217.1.246 121 170.210.208.108 127 141.98.11.110 134 89.39.246.21 144 167.99.89.165 193 101.42.25.236 209 222.</description>
    </item>
    <item>
      <title>通过设置训练集，交叉验证集和测试集来选择模型，优化算法（吴恩达机械学习部分课程总结）</title>
      <link>https://0ha.top/posts/129390567/</link>
      <pubDate>Tue, 20 Jun 2023 12:34:41 +0000</pubDate>
      <guid>https://0ha.top/posts/129390567/</guid>
      <description>目录&#xA;前因&#xA;​编辑​编辑&#xA;解决办法&#xA;类比思想&#xA;小白第一次发文，有错误欢迎指出。&#xA;前因 看吴恩达老师机器学习的模型选择与交叉验证训练集之后的总结&#xA;在通过数据来拟合图像的时候会遇到一个这么一个问题。&#xA;如图此函数虽然可以几乎完美的拟合训练集但是他的泛性可能会很低，这就是拟合中的常见问题——过拟合。&#xA;通过训练集来求代价函数的最小值，从而得出来d(函数的最大次方) 为4，听起来好像是对的，解决了问题，but，训练集只能用来训练w和b，不能用来判断w的最高次也就是d等于多少，这个方法就是用训练集来优化d，而d是一个老师设置的另外的参数，不参与计算，所以这是不可取的。那怎么办呢？ 解决办法 通过设置训练集以及交叉验证集来优化，大概分布如上 此时通过训练集来拟合w与b ，同时重新再利用交叉验证集来判断d的大小，这样就可以同时确定w,b,d，因为在拟合w与b的时候交叉验证集没有参与计算，故w和b不受其影响。 类比思想 同样的思想可以类比神经网络来确定它的隐藏层，用所有的数据进行分类，再用交叉验证集带入计算求jcv(W_i,B_i)最小值，来判断最优的神经网络结构。 </description>
    </item>
    <item>
      <title>C&#43;&#43;红黑树（1/4）</title>
      <link>https://0ha.top/posts/131152321/</link>
      <pubDate>Tue, 20 Jun 2023 12:25:50 +0000</pubDate>
      <guid>https://0ha.top/posts/131152321/</guid>
      <description>目录&#xA;下一篇博客&#xA;红黑树的优点以及特点&#xA;为什么要使用c++来创建红黑树&#xA;红黑树的定义/特性&#xA;举例&#xA;代码&#xA;解释一下为什么新定义的叶子结点的初始值为红色而不为黑色&#xA;本节总结&#xA;下一篇博客 C++红黑树（2/4）_木木em哈哈的博客-CSDN博客https://blog.csdn.net/mumuemhaha/article/details/131159253?spm=1001.2014.3001.5502 ;&#xA;红黑树的优点以及特点 红黑树是一种自平衡二叉查找树，它能够保证在最坏情况下基本动态集合操作（插入、删除、查找）的时间复杂度为O(log n)。红黑树通过在每个节点上增加一个存储位来表示节点的颜色，可以将树保持黑平衡，具体来说就是满足任何一条从根到叶子节点的路径上的黑节点数量相等。红黑树的性质包括：根节点是黑色的；每个叶子节点都是黑色的空节点；如果一个节点是红色的，则它的两个子节点都是黑色的；任意一节点到其每个叶子的所有路径都包含相同数目的黑色节点。这些性质保证了红黑树的平衡性和查找效率。&#xA;为什么要使用c++来创建红黑树 C++ 使用红黑树是为了保证数据结构的平衡和高效地支持插入、删除、查找等操作。红黑树也是关联容器 map 和 set 的底层实现之一。并且可以更好的理解指针和逻辑思维能力。 并且相对于二叉树和其他树，红黑树可以实现相对更快的查找 但是相对于其他的树，它的平衡性调整会比较繁琐也比较难理解&#xA;红黑树的定义/特性 红黑树只会出现红色节点以及黑色节点且根节点一定是黑色 所有叶子节点到根节点所经过的黑色节点一定相同 最短路径的两倍不会超过最长路径 举例 如图&#xA;这是一棵红黑树&#xA;而下面都不是红黑树&#xA;不符合第三个条件：&#xA;所有叶子节点到根节点所经过的黑色节点一定相同&#xA;不符合第二个条件&#xA;红色节点不能相邻出现（黑色可以）&#xA;代码 则我们可以看到写出c++/c的代码&#xA;#include using namespace std; enum Colour//定义一个颜色 { RED, BLACK, }; template//定义一个模版T struct RBNode//一个节点的结构体 { RBNode* lchild, * rchild, * parent; T&#x9;data; Colour colour=RED;//初始化为RED也可以后面定义一个初始化函数 }; template //再定义一个模版T（template只能联系到下面一句语句） class RBTree//树 { public: RBTree() { root = nullptr; } ~RBTree() { ReleaseNode(root); } private: void ReleaseNode(RBNode* pnode)//删除节点，释放内存 { if (pnode !</description>
    </item>
    <item>
      <title>c&#43;&#43;红黑树（4/4）</title>
      <link>https://0ha.top/posts/131296981/</link>
      <pubDate>Tue, 20 Jun 2023 12:15:47 +0000</pubDate>
      <guid>https://0ha.top/posts/131296981/</guid>
      <description>目录&#xA;回顾&#xA;情况&#xA;假如父亲在爷爷的左节点上，插入的节点在父亲的右节点&#xA;打脸.jpg&#xA;如果有叔叔节点&#xA;假如父亲在爷爷的右节点上&#xA;插入的节点在父亲的右节点&#xA;插入的节点在父亲的左节点&#xA;对于上一章所讲的新节点最好不要变（阿巴阿巴&amp;hellip;）&#xA;小技巧&#xA;代码实现&#xA;左旋节点&#xA;先左旋后右旋&#xA;先右旋再左旋&#xA;分类&#xA;总代码&#xA;总结&#xA;回顾 上期的博客&#xA;c++红黑树（3/4）_木木em哈哈的博客-CSDN博客https://blog.csdn.net/mumuemhaha/article/details/131191005?spm=1001.2014.3001.5501 ;&#xA;在上一期的博客中我们学到了第二种情况红黑树如何进行平衡性调整&#xA;接下来我们要试试剩下的情况，红黑树如何进行平衡性调整&#xA;其实说是这一章一共三种情况，但是如果理解了前面两章，其实要比前两章简单的多得多&#xA;情况 假如父亲在爷爷的左节点上，插入的节点在父亲的右节点 （往下的情况默认没叔叔节点或者叔叔节点为黑）&#xA;做法很简单——只需要先做左旋再右旋&#xA;这样节点就行了&#xA;接下来就是变色了&#xA;打脸.jpg emmm&amp;hellip;&amp;hellip;&#xA;上一章好像讲过新节点最好不要变色来着&amp;hellip;.&#xA;这个我后面会解释&#xA;如果有叔叔节点 就是这样变&#xA;类似就是加了一个叔叔节点的变化&#xA;假如父亲在爷爷的右节点上 这时只需要左右反过来就行了，会更好理解&#xA;插入的节点在父亲的右节点 此时只需要与之相反的左旋就行了&#xA;如果有叔叔节点就是&#xA;插入的节点在父亲的左节点 这个只需要与之相反的先做右旋在做左旋&#xA;然后老样子&#xA;如果有叔叔节点就是其实&#xA;这样所有的就完成了&#xA;对于上一章所讲的新节点最好不要变（阿巴阿巴&amp;hellip;） 这是因为一个特殊情况必须要把新节点当成一个整体&#xA;但是，仔细看&#xA;无论如何变交换的时候只要把30这个节点交换就行了&#xA;其他的不用变，自然而然，新节点就可以变色&#xA;小技巧 左旋右旋只需要判断是左节点向下&amp;quot;拉&amp;quot;还是右节点向下&amp;quot;拉&amp;quot;&#xA;代码实现 其实这里没有什么好说的，左旋只是相反的右旋，只需要把所有的方向一变就行&#xA;左旋节点 void RotateLeft(RBNode*&amp;amp; pointer) { // 4 -----左旋---- 6 // / \ / \ // 3 6 4 7 // / \ / \ // 5 7 3 5 RBNode* node_1 = pointer; pointer = pointer-&amp;gt;rchild; pointer-&amp;gt;parent = node_1-&amp;gt;parent; node_1-&amp;gt;rchild = pointer-&amp;gt;lchild; if (pointer-&amp;gt;lchild) pointer-&amp;gt;lchild-&amp;gt;parent = node_1; pointer-&amp;gt;lchild = node_1; node_1-&amp;gt;parent = pointer; } 先左旋后右旋 这里附上先左旋在右旋的节点</description>
    </item>
    <item>
      <title>c&#43;&#43;红黑树（3/4）</title>
      <link>https://0ha.top/posts/131191005/</link>
      <pubDate>Mon, 19 Jun 2023 16:15:27 +0000</pubDate>
      <guid>https://0ha.top/posts/131191005/</guid>
      <description>目录&#xA;回顾&#xA;情况&#xA;解决办法&#xA;右旋&#xA;变色&#xA;接上一章的问题&#xA;代码讲解&#xA;判断爷爷是左节点还是右节点&#xA;右旋函数代码&#xA;选择情况并且执行右旋函数代码&#xA;连接到原来的树上&#xA;注意事项&#xA;总代码&#xA;总结&#xA;回顾 上期的博客&#xA;C++红黑树（2/4）_木木em哈哈的博客-CSDN博客https://blog.csdn.net/mumuemhaha/article/details/131159253?spm=1001.2014.3001.5501 ;下期博客&#xA;c++红黑树（4/4）_木木em哈哈的博客-CSDN博客https://blog.csdn.net/mumuemhaha/article/details/131296981?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22131296981%22%2C%22source%22%3A%22mumuemhaha%22%7D ;&#xA;在上一期的博客中我们学到了第一种情况红黑树如何进行平衡性调整&#xA;接下来我们要试试第二种情况，红黑树如何进行平衡性调整&#xA;情况 第二种情况就是父亲节点为红色，叔叔节点没有或者为黑色，父亲节点为爷爷的左节点，且爷爷节点为曾祖父（爷爷的父亲）节点的左节点。&#xA;就是这么一个图&#xA;解决办法 这里要把节点进行右旋&#xA;在这里可能听起来会比较难以理解&#xA;但是记住你需要做的步骤，代码就可以很简单的进行实现&#xA;右旋 把曾祖父的左孩子指针从祖父那里断开（同时也断开祖父的父亲指针）&#xA;然后曾祖父的左孩子指针指向父亲节点&#xA;同时把父亲节点得到右指针指向祖父节点，如果父亲节点有右孩子节点需要把他提取出来放到原曾祖父的左孩子（同时连接祖父的父亲指针，后面都记得变，不说了）&#xA;就完成了右旋的操作&#xA;结果图为&#xA;变色 这个时候只需要变色就行了&#xA;把你的父亲节点变为黑色，同时把原爷爷节点变为红色&#xA;就为下图&#xA;这时候红黑树就进行了平衡&#xA;接上一章的问题 上一章的图片为&#xA;还记得我们上一回记住的吗？&#xA;把篮圈内的部分看为一个整体（因为他已经平衡了）&#xA;这时候他就是新的红色节点&#xA;他的父亲为&amp;quot;50&amp;quot;，他的祖父为&amp;quot;80&amp;quot;&#xA;可能看起来会比较复杂&#xA;我们只需要记住操作&#xA;由于没有曾祖父所以不需要改曾祖父的节点&#xA;把父亲的节点的右孩子连接到祖父节点，再把原父亲右孩子节点连接到祖父的左节点&#xA;这样宏观的结果就是相当于把爷爷节点&amp;quot;拽&amp;quot;了下来&#xA;最后的图为&#xA;最后进行变色&#xA;一个红黑树到达平衡&#xA;代码讲解 首先接在上一章情况之后&#xA;代码&#xA;判断爷爷是左节点还是右节点 //（uncle != nullptr &amp;amp;&amp;amp; uncle-&amp;gt;colour == RED）不满足 int sign = 0; RBNode* gff = grandpa-&amp;gt;parent; //标记数据sign判断祖父节点与曾祖父节点的关系 if (gff !</description>
    </item>
    <item>
      <title>C&#43;&#43;红黑树（2/4）</title>
      <link>https://0ha.top/posts/131159253/</link>
      <pubDate>Tue, 13 Jun 2023 09:14:20 +0000</pubDate>
      <guid>https://0ha.top/posts/131159253/</guid>
      <description>目录&#xA;回顾&#xA;情况&#xA;局部解决办法&#xA;全局解决的思想&#xA;代码&#xA;深入到叶子节点准备插入新数据&#xA;准备插入数据&#xA;插入&#xA;出现本章情况&#xA;祖父节点赋值&#xA;叔叔节点赋值&#xA;变色——进行平衡性调整&#xA;总代码&#xA;注意事项&#xA;总结&#xA;回顾 上一章&#xA;C++红黑树（1/4）_木木em哈哈的博客-CSDN博客https://blog.csdn.net/mumuemhaha/article/details/131152321?spm=1001.2014.3001.5501 ;&#xA;下一章&#xA;红黑树c++（3/4）_木木em哈哈的博客-CSDN博客https://blog.csdn.net/mumuemhaha/article/details/131191005?spm=1001.2014.3001.5501 ;&#xA;上一章学到了红黑树的特点以及基本定义&#xA;本章我们要学插入时候的第一类情况——父亲节点为红色叔叔节点也为红（当然祖父节点一定为黑色）&#xA;情况 当我的红色节点插上去时因为特性二——红色节点不可以相邻出现从而要对整个树进行平衡性调整&#xA;我们可以把新节点的颜色不变，然后把父亲节点和叔叔节点的颜色变为黑色，然后把爷爷节点的颜色变为红色&#xA;局部解决办法 从而达到这棵树的平衡&#xA;需要注意的是如果祖父是根节点的话要把祖父的颜色也调为黑色&#xA;全局解决的思想 然而不幸的是一颗树的深度不仅仅可以是3，他可以更深——4，5,，6，7&amp;hellip;或者更多&#xA;如图&#xA;要在这个红黑树上把插入一个新的红色节点&#xA;那么还是安装之前的方法调整你会发现一个问题就是你插入节点的祖父节点的父亲节点（也就是你的曾祖父节点）是红色的且你祖父节点的叔叔节点是黑色不在这一类方法中&#xA;如图&#xA;但是不要慌张，后面两节会讲到其他的情况以及应对的方法（需要注意的时在后续解决中你要把蓝圈部分当成一个整体【因为他已经平衡了】）&#xA;现在恭喜你，你已经学到了红黑树插入时会遇到的第一种情况的解决办法&#xA;接下来就是代码讲解了&#xA;代码 首先我要创建一个RBTree（红黑树）的类&#xA;分别有lchild（左孩子）rchild（右孩子）parent（父母节点）data（自身的数据）color（颜色）&#xA;这几个类别除去color为RED（红色）其他全为空（nullptr）上一章讲过了&#xA;深入到叶子节点准备插入新数据 while (point-&amp;gt;data==nullptr) { if (e == point-&amp;gt;data) { printf(&amp;#34;该数据已经存在&amp;#34;); return; } parent = point; if (e &amp;gt;= point) point = point-&amp;gt;rchild; else point = point-&amp;gt;lchild; } 和其他的树一样，大的在右边，小的在左边重复数据插不了</description>
    </item>
    <item>
      <title>通过python用超级简单和基本的方法实现求导数</title>
      <link>https://0ha.top/posts/130782037/</link>
      <pubDate>Sun, 11 Jun 2023 03:03:50 +0000</pubDate>
      <guid>https://0ha.top/posts/130782037/</guid>
      <description>直接利用数学中导数的定义就行&#xA;代码实现就是&#xA;MIN=1e-9 #&amp;amp;#x4E00;&amp;amp;#x4E2A;&amp;amp;#x8DB3;&amp;amp;#x591F;&amp;amp;#x5C0F;&amp;amp;#x7684;&amp;amp;#x6570;&#xD;import numpy as np&#xD;def f_yuan(x_2):&#xD;y_2=x_2**2 #&amp;amp;#x8FD9;&amp;amp;#x91CC;&amp;amp;#x7684;&amp;amp;#x51FD;&amp;amp;#x6570;&amp;amp;#x53EF;&amp;amp;#x4EE5;&amp;amp;#x6539;&#xD;return y_2&#xD;def F_daoshu_yuan(x_1):&#xD;a_1=(f_yuan(x_1+MIN)-f_yuan(x_1))/MIN&#xD;return a_1&#xD;A_1=F_daoshu_yuan(1)&#xD;print(A_1)&#xD;print(&amp;#34;*******************************************&amp;#34;)&#xD;A_2=F_daoshu_yuan(10)&#xD;print(A_2)&#xD;print(&amp;#34;*******************************************&amp;#34;)&#xD;A_3=F_daoshu_yuan(1000)&#xD;print(A_3)&#xD;print(&amp;#34;*******************************************&amp;#34;)&#xD;A_4=F_daoshu_yuan(10000)&#xD;print(A_4)&#xD;print(&amp;#34;*******************************************&amp;#34;)&#xD;# 2.000000165480742&#xD;# *******************************************&#xD;# 20.00000165480742&#xD;# *******************************************&#xD;# 2000.0152289867399&#xD;# *******************************************&#xD;# 20012.259483337402&#xD;# *******************************************&#xD;#&#xD;# &amp;amp;#x8FDB;&amp;amp;#x7A0B;&amp;amp;#x5DF2;&amp;amp;#x7ED3;&amp;amp;#x675F;,&amp;amp;#x9000;&amp;amp;#x51FA;&amp;amp;#x4EE3;&amp;amp;#x7801;0 优缺点 优点是泛用性非常好，也十分好理解，在合适的范围，函数可以变得不规则，但是依旧可以求出导数的大约值，并不会与真实值差的很多&#xA;缺点很明显在数据十分大的时候误差也会越来越大，原因就是MIN的值还是太大了。</description>
    </item>
    <item>
      <title>python爬虫“indexerror: list index out of range”错误及其解决办法</title>
      <link>https://0ha.top/posts/131097025/</link>
      <pubDate>Sat, 10 Jun 2023 04:10:23 +0000</pubDate>
      <guid>https://0ha.top/posts/131097025/</guid>
      <description>开始的认为原因&#xA;源代码（总）&#xA;真正原因&#xA;解决办法&#xA;问题总结&#xA;个人总结&#xA;在写爬虫代码时候代码报错&#xA;indexerror: list index out of range indexerror:列表索引超出范围&#xA;开始的认为原因 前一期的博客我准备爬取盗版小说的的小说时，因为加载的字数太多&#xA;我就想然后就是因为这个报了这个错误&#xA;带上代码&#xA;import requests import re import numpy as np from bs4 import BeautifulSoup #目标url url=&amp;#39;http://www.ibiqu.org/148_148106/&amp;#39; #主页网站，不加的话还要后面分离链接 url2=&amp;#39;http://www.ibiqu.org&amp;#39; #定义头文件 head_bqg={ &amp;#39;User-Agent&amp;#39;:&amp;#39;Mozilla/5.0 (Linux; A } html_zhuye=requests.get(url,headers=head_bq html_1=BeautifulSoup(html_zhuye.text,&amp;#39;html. html_1.select(&amp;#39;body &amp;gt; div.cover &amp;gt; ul &amp;gt; a &amp;gt;h html_1=str(html_1) ex=&amp;#39; 真正原因 后来我想到那为什么还有其他的文字的python项目爬虫爬取的项目比我长了好几倍，但是它依然不会报错&#xA;不对劲，我感觉&#xA;后来我联系源码内容&#xA;想到是不是因为我的一些数据下标没有（也就是空数组），导致下面代码&#xA;txt_2=re.sub(ex_1,&amp;rsquo;&amp;rsquo;,txt_2[0]) txt_2=str(txt_2)[2:-2]&#xA;根本找不到下标&#xA;最后不图省事了，直接遍历列表，这样空的列表也就会跳过&#xA;for txt_3 in txt_2: txt_3=re.sub(ex_1,&amp;#39;&amp;#39;,txt_3) file_1.writelines(f&amp;#39;{txt_3}\n&amp;#39;) 结果十分奇怪，它不报错了，但是好像要加载很久，过一段时间再想一想这里还有没有优化的内容&#xA;实在不行就直接把需要爬取的链接存取到列表里然后运行一次程序爬取一行链接存储到文档中。&#xA;所以最后总代码</description>
    </item>
    <item>
      <title>pip永久换源和临时换源的方法</title>
      <link>https://0ha.top/posts/131077450/</link>
      <pubDate>Tue, 06 Jun 2023 14:56:33 +0000</pubDate>
      <guid>https://0ha.top/posts/131077450/</guid>
      <description>为什么要换源 因为在pip下载python包时由于服务器架设在国外这样国内访问掉包率和速度会很慢 后一种还好，前一种下载体积大的包不可避免会超时，这样就要用到国内的镜像源了&#xA;第一种（非永久改源） 这一种只需要在下载的包名后加一个&amp;quot;-i 镜像链接&amp;quot;&#xA;下面是几个常用的镜像&#xA;清华大学：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：https://mirrors.aliyun.com/pypi/simple 中国科学技术大学 https://pypi.mirrors.ustc.edu.cn/simple 豆瓣：https://pypi.douban.com/simple 那么命令就是&#xA;pip install 包名 -i https://mirrors.aliyun.com/pypi/simple 第二种方法（永久改源） 在&amp;quot;C:\Users%username%\AppData\Roaming&amp;quot;目录下（或者直接在地址栏输入%username%）&#xA;创建一个pip.ini&#xA;输入以下命令&#xA;[global] timeout = 6000 index-url = https://pypi.tuna.tsinghua.edu.cn/simple trusted-host = pypi.tuna.tsinghua.edu.cn 其中链接index-url和trusted-host可以改为其他的镜像源&#xA;最好重启一下&#xA;应该就可以了&#xA;一些改源时候会遇到的问题 一部分的pip源链接可能是http格式的（不是https格式）这样下载时可能会出警告甚至报错&#xA;ERROR: Could not find a version that satisfies the requirement pandas (from versions: none) ERROR: No matching distribution found for pandas&#xA;注意改为https格式的链接就行&#xA;部分镜像源的部分包的部分老版本可能会没有，如果下载不到相应版本还是换成官方的镜像源下载吧。</description>
    </item>
    <item>
      <title>Xftp“无法显示远程文件夹”</title>
      <link>https://0ha.top/posts/131031052/</link>
      <pubDate>Sun, 04 Jun 2023 05:02:18 +0000</pubDate>
      <guid>https://0ha.top/posts/131031052/</guid>
      <description>目录&#xA;问题&#xA;解决办法&#xA;无关知识提一嘴&#xA;问题 如图打开xftp点开root文件夹或者是其他的一些目录准备传输文件时会出现，无法显示远程文件夹&#xA;这是因为xftp没有访问目录权限导致的&#xA;（csdn上一些的博主说是要改为被动模式，当时xftp默认就是开启的被动模式所以目前问题不在这里，至少我不是）&#xA;解决办法 那就在xftp上重新打开xshell，注意！！！必须是在xftp上重新打开&#xA;然后在新的xshell中进入管理员模式&#xA;sudo -i 给予目录权限的命令&#xA;比如我要xftp访问/root文件夹就输入&#xA;chmod 777 /root 后面的/root文件夹可以改为你要访问文件的绝对路径&#xA;无关知识提一嘴 要注意的是普通模式默认进入的是/home/你的主机名称&#xA;root模式下目录是&amp;quot;/root&amp;quot;，不是&amp;quot;/&amp;ldquo;根目录</description>
    </item>
    <item>
      <title>“13”行纯python代码把目录下相应后缀名称的文件写入txt中</title>
      <link>https://0ha.top/posts/131015437/</link>
      <pubDate>Sun, 04 Jun 2023 04:00:23 +0000</pubDate>
      <guid>https://0ha.top/posts/131015437/</guid>
      <description>如标题&#xA;可以用于yolo项目中所需要的写入图片的绝对路径那一个环节&#xA;也可以用于其他的情况（博主想不出来）&#xA;import os file_name_1=input(&amp;#39;输入要创建准备写入txt的的文件名称：&amp;#39;) file_1=open(f&amp;#39;{file_name_1}.txt&amp;#39;,mode=&amp;#39;w&amp;#39;,encoding=&amp;#39;utf-8&amp;#39;) path_1=input(&amp;#39;输入图片的路径： &amp;#39;) type_1=input(&amp;#39;输入写入txt的文件后缀名称：&amp;#39;) sum1s=os.listdir(path_1) # 把文件输入的路径下的文件遍历 for sum1 in sum1s: sum2=os.path.splitext(sum1) #判断后缀名称是不是输入类型的（sum2[1]为输入类型的后缀名） if sum2[1]==f&amp;#39;.{type_1}&amp;#39;: sum3=os.getcwd() sum5=f&amp;#39;{sum3}{sum1}&amp;#39; file_1.writelines(f&amp;#39;{sum5}\n&amp;#39;) print(f&amp;#39;已写入 {sum5}到{file_name_1}.txt中&amp;#39;) </description>
    </item>
    <item>
      <title>用python实现划分自定义划分训练集，测试集和验证集</title>
      <link>https://0ha.top/posts/131021670/</link>
      <pubDate>Sun, 04 Jun 2023 03:58:36 +0000</pubDate>
      <guid>https://0ha.top/posts/131021670/</guid>
      <description>用于yolo自定义分配训练集测试集以及验证集&#xA;# coding:utf-8 import os import numpy as np import random print(&amp;#34;输入接下来各个集合所占的比例(一般为0.8:0.1:0.1）:&amp;#34;) train_percent=input(&amp;#34;输入训练集所占的比例:&amp;#34;) train_percent=float(train_percent) test_percent=input(&amp;#34;输入测试集所占的比例:&amp;#34;) test_percent=float(test_percent) val_percent=input(&amp;#34;输入验证集所占的比例:&amp;#34;) val_percent=float(val_percent) #创建文件 if not os.path.exists(&amp;#39;./path&amp;#39;): os.mkdir(&amp;#39;./path&amp;#39;) file_train=open(&amp;#39;./path&amp;#39;+&amp;#39;/train.txt&amp;#39;,mode=&amp;#39;w&amp;#39;) file_test=open(&amp;#39;./path&amp;#39;+&amp;#39;/test.txt&amp;#39;,mode=&amp;#39;w&amp;#39;) file_val=open(&amp;#39;./path&amp;#39;+&amp;#39;/val.txt&amp;#39;,mode=&amp;#39;w&amp;#39;) path_images=input(&amp;#34;输入训练所需图片的路径:&amp;#34;) # path_Annotations=input(&amp;#34;输入训练所需标注集的路径:&amp;#34;) file_images_real=np.empty([0,2]) train_images=os.listdir(path_images) #计算各个训练集的长度 len_images=len(train_images) len_train=len_images*train_percent len_train=int(len_train) len_test=len_images*test_percent len_test=int(len_test) len_val=len_images*val_percent len_val=int(len_val) for train_image in train_images: file_name=os.path.splitext(train_image) if file_name[1]==&amp;#39;.jpg&amp;#39; or file_name[1]==&amp;#39;.png&amp;#39;: file_images_real=np.append(file_images_real,[file_name],axis=0) # file_images_real=np.reshape(file_images_real,(-1,2)) #改形状也行 #开始分配数据 train_counts=random.sample(range(0,len_images),len_train) test_counts=random.sample(range(0,len_images),len_test) val_counts=random.sample(range(0,len_images),len_val) #写入数据 for train_count in train_counts: file_train.writelines(f&amp;#39;{file_images_real[train_count][0]}\n&amp;#39;) for test_count in test_counts: file_test.writelines(f&amp;#39;{file_images_real[test_count][0]}\n&amp;#39;) for val_count in val_counts: file_val.</description>
    </item>
    <item>
      <title>（win10)yolov5训练自己的数据集</title>
      <link>https://0ha.top/posts/130999472/</link>
      <pubDate>Fri, 02 Jun 2023 01:50:05 +0000</pubDate>
      <guid>https://0ha.top/posts/130999472/</guid>
      <description>目录&#xA;环境：&#xA;python包的配置&#xA;文件夹路径&#xA;标注数据&#xA;获取电脑/视频里的图片&#xA;开始标记数据&#xA;划分划分训练集、验证集、测试集&#xA;把相应的文件路径存入txt文件中，xml转为txt&#xA;创建配置文件&#xA;聚类获得先验框&#xA;开始训练&#xA;运行文件：&#xA;用gpu训练&#xA;查看cuda版本&#xA;​编辑&#xA;安装pytorch&#xA;训练&#xA;问题&#xA;如果出现 （页面太小，无法完成操作）的相关问题&#xA;参考文章：&#xA;环境： windows 10 yolov5的源文件（链接yolov5） 标注工具（链接标注） python包的配置 打开pycharm的终端&#xA;运行&#xA;pip install -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple 文件夹路径 在data文件中创建一个VOCData文件&#xA;进入VOCData文件夹里面创建一个Annotations文件夹用于放置你标记的数据集的数据xml或者是txt，再在VOCData文件夹里面创建一个images的文件夹里面用于放你的训练的图片&#xA;先创建好，有没有还没有关系。&#xA;标注数据 接下来就是标注数据集了&#xA;打开上面的标注数据的工具（原来用于dnf挂机的脚本工具，用了发现他的自动截图功能不错，而且标记出来的数据labels可以直接用，不用xml转txt了）&#xA;获取电脑/视频里的图片 打开自动截图&#xA;要设置区域可以按照上面的文字来设置截图区域&#xA;然后开启全屏，之后直接ctrl+q键开始截图就行了（默认时间是3秒自动截图一次）&#xA;默认是png，我用的jpg，为了防止后面代码报错，最好也改成这个吧&#xA;截图文件在软件目录下的的&amp;quot;截图&amp;quot;文件夹&#xA;开始标记数据 点击&amp;quot;打开图库&amp;quot;&#xA;把刚刚 截图的图片给复制进去&#xA;然后重启一次软件就可以开始标记了&#xA;需要注意的是最后要把没有任何标记的图片删除，以防后面执行代码时报错&#xA;划分划分训练集、验证集、测试集 在data/VOCData文件目录下面创建一个py文件（名字随意，认得出来就行）&#xA;# coding:utf-8 import os import random import argparse parser = argparse.ArgumentParser() #xml文件的地址，根据自己的数据进行修改 xml一般存放在Annotations下 parser.</description>
    </item>
    <item>
      <title>一篇就够了——宝塔安装nextcloud以及一系列的软件（ocdownload，onlyoffice）安装,以及会遇到的一系列问题（持续更新）</title>
      <link>https://0ha.top/posts/130904547/</link>
      <pubDate>Tue, 30 May 2023 13:17:52 +0000</pubDate>
      <guid>https://0ha.top/posts/130904547/</guid>
      <description>目录&#xA;前言&#xA;什么是宝塔&#xA;什么是nextcloud&#xA;为什么不用docker来安装nextcloud&#xA;下载&#xA;版本选择和下载链接&#xA;小提示&#xA;安装&#xA;选择数据库&#xA;下载ocdown&#xA;配置aira2c&#xA;安装onlyoffice&#xA;插件安装&#xA;目前出现的问题（持续更新）&#xA;无法删除和移动文件&#xA;特别感谢&#xA;前言 什么是宝塔 宝塔是一款用于 Linux 服务器管理的开源面板软件，其提供了网站管理、数据库管理、FTP管理、SSL证书申请等功能，可以方便地进行服务器管理和网站运营。它支持多语言界面，易于安装和使用，受到了广大开发者和网站管理员的喜爱。&#xA;尽管宝塔相比于其他一些方式建站占用的空间和cpu资源会比较大&#xA;但是其简单的部署方式和一体化的管理十分方便后续管理和拓展&#xA;什么是nextcloud Nextcloud是一种开源的云存储平台，它可以让你在自己的服务器上存储、同步和分享文件、日历、联系人等信息。它提供了类似于Google Drive和Dropbox的功能，但你完全掌控你自己的数据。你可以在你的服务器上安装Nextcloud，或者使用Nextcloud提供的托管服务。&#xA;宝塔下载完成现在可以搭建一个自己的网盘&#xA;为什么不用docker来安装nextcloud 之前用过可道云的云盘，那个桌面和文档流畅度确实好用不过内网上传速度10m/s下载速度40m/s,而且上传文件时的cpu占用率特别特别高。&#xA;（2023年5月30日更新！！！）博主搞清楚原因了，现在如果使用的人不超过10个，比较推荐可道云，安装好后参考下面教程&#xA;可道云优化下载速度和性能教程https://blog.csdn.net/mumuemhaha/article/details/130956982?spm=1001.2014.3001.5502 ;&#xA;nextcloud可以用docker来部署，但是docker中部署的话如果要用到数据库会比较麻烦，之前废了好大的劲部署好结果一个重启直接干废了，网站直接报错。就放弃了&#xA;相反宝塔可以非常方便的部署数据库和管理数据库（不过好像docker部署的nextcloud本地上传速度有40m/s，而宝塔部署的只有20m/s不到的速度，不知道是不是宝塔限制了网速反正我调了但还是比较满）&#xA;下载 版本选择和下载链接 首先下载好网站文件下载链接&#xA;选择一个版本，不要太新了，不然安装的插件可能会报错，也不要太老了，原因同上。&#xA;然后就是一样安装网站的步骤，下载上传解压，然后最后设置端口和域名。&#xA;需要注意的是不同版本的nextcloud需要的php可能不会一样不过问题不大，下载发现出错。就下载相应的php版本然后记得调回相应的php就行&#xA;小提示 记得把防跨站攻击关了，以防报错&#xA;安装 这里没有图片借用一下这个博主的图片 乐乐呀168&#xA;（侵删）&#xA;选择数据库 如果要多用户使用的话还是强烈推荐选择MYSQL的数据库&#xA;但是如果单独几个人使用的话差别也不是很大&#xA;有人会觉得那这样的话docker和宝塔部署不就一样了？docker还会更方便。&#xA;但是docker管理文件会比较麻烦尤其是云盘类文件管理会比较简单&#xA;数据库的账号密码就输之前创建的&#xA;下载ocdown 然后就是下载插件&#xA;搜索ocdownload&#xA;然后下载【现在还是用不了了需要配置】&#xA;配置aira2c 打开登录ssh下载（这里是debian其他的类推）&#xA;apt-get install aria2 创建配置文件目录并且赋予权限&#xA;mkdir /etc/aria2 chmod 777 /etc/aria2 创建配置文件&#xA;touch /etc/aria2/aria2.</description>
    </item>
    <item>
      <title>可道云修改配置优化上传下载速度</title>
      <link>https://0ha.top/posts/130956982/</link>
      <pubDate>Tue, 30 May 2023 13:10:20 +0000</pubDate>
      <guid>https://0ha.top/posts/130956982/</guid>
      <description>目录&#xA;前言&#xA;下载php插件并配置&#xA;配置nginx&#xA;参考&#xA;前言 不久前我做nextcloud的时候说过好像可道云下载和上传速度没有nextcloud大，而且在上传文件的时候cpu占用率到达百分之百。&#xA;我的四代i3虽然不高，但是当个私人网盘的处理器这配置绰绰有余啊？&#xA;后面我就在想是可道云的问题还是设置的问题&#xA;后面我nextcloud上传大文件的时候报错在一步步查原因是刚好把可道云的设置问题给找到了&#xA;下载php插件并配置 安装就不教了，一键部署就行&#xA;下载下列插件&#xA;然后在设置列表中把配置改成这个样子&#xA;配置nginx 打开nginx的配置文件并修改&#xA;client_max_body_size这一行改为0m（也就是无限制）&#xA;或者直接打开性能调整修改&#xA;其实这里速度就上去了（尤其是上传速度，而且cpu也不会满负载了）&#xA;然后保险起见在配置一下可道云客户端&#xA;把他改大一些就行&#xA;这时候上传速度可以了(内网速度）&#xA;cpu也不会百分百了（喜）&#xA;参考 参考文章</description>
    </item>
    <item>
      <title>记录PIP安装出现的一系列错误</title>
      <link>https://0ha.top/posts/130396342/</link>
      <pubDate>Sun, 28 May 2023 11:28:15 +0000</pubDate>
      <guid>https://0ha.top/posts/130396342/</guid>
      <description>在安装pandas时运行&#xA;pip install Pandas 结果出现报错&#xA;ERROR: Exception:&#xD;Traceback (most recent call last):&#xD;File &amp;#34;C:\Users\mumuemhaha\.conda\envs\mumuemhaha\lib\site-packages\pip\_vendor\urllib3\response.py&amp;#34;, line 438, in _error_catcher&#xD;yield&#xD;File &amp;#34;C:\Users\mumuemhaha\.conda\envs\mumuemhaha\lib\site-packages\pip\_vendor\urllib3\response.py&amp;#34;, line 561, in read&#xD;data = self._fp_read(amt) if not fp_closed else b&amp;#34;&amp;#34;&#xD;File &amp;#34;C:\Users\mumuemhaha\.conda\envs\mumuemhaha\lib\site-packages\pip\_vendor\urllib3\response.py&amp;#34;, line 527, in _fp_read&#xD;return self._fp.read(amt) if amt is not None else self._fp.read()&#xD;File &amp;#34;C:\Users\mumuemhaha\.conda\envs\mumuemhaha\lib\site-packages\pip\_vendor\cachecontrol\filewrapper.py&amp;#34;, line 90, in read&#xD;data = self.__fp.read(amt)&#xD;File &amp;#34;C:\Users\mumuemhaha\.conda\envs\mumuemhaha\lib\http\client.py&amp;#34;, line 466, in read&#xD;s = self.fp.read(amt)&#xD;File &amp;#34;C:\Users\mumuemhaha\.conda\envs\mumuemhaha\lib\socket.py&amp;#34;, line 705, in readinto&#xD;return self.</description>
    </item>
    <item>
      <title>数据处理——用numpy的empty等方法把许多numpy数组变为一个大的每个独立的数组</title>
      <link>https://0ha.top/posts/130755371/</link>
      <pubDate>Sat, 20 May 2023 07:11:28 +0000</pubDate>
      <guid>https://0ha.top/posts/130755371/</guid>
      <description>目录&#xA;数据处理的问题&#xA;利用reshape函数用来修改形状&#xA;利用empty来创建一个数组用来存储多个数据&#xA;数据处理的问题 在数据处理的过程有时我们为了方便管理会把多个小数组合并为一个大数组，但是初学者用简单的多个array[]合并会遇到一个问题&#xA;import numpy as np&#xD;a=np.array([1,2])&#xD;b=np.array([3,4])&#xD;a=np.append(a,b)&#xD;print(a) 这样也许不是我们想要的，我们想要的是多个二维数组而不是一个单一的一维数组&#xA;利用reshape函数用来修改形状 还是刚刚的代码只需要稍作修改&#xA;import numpy as np&#xD;a=np.array([1,2])&#xD;b=np.array([3,4])&#xD;a=np.append(a,b)&#xD;a=np.reshape(a,(-1,2)) #np.reshape(array,shape)&amp;amp;#x5176;&amp;amp;#x4E2D;-1&amp;amp;#x4EE3;&amp;amp;#x8868;&amp;amp;#x7684;&amp;amp;#x5C31;&amp;amp;#x662F;&amp;amp;#x7A7A;&amp;amp;#xFF0C;&amp;amp;#x8FD9;&amp;amp;#x91CC;&amp;amp;#x7684;&amp;amp;#x610F;&amp;amp;#x601D;&amp;amp;#x5C31;&amp;amp;#x662F;&amp;amp;#x884C;&amp;amp;#x6570;&amp;amp;#x6570;&amp;amp;#x968F;&amp;amp;#x4FBF;&amp;amp;#x5217;&amp;amp;#x6570;&amp;amp;#x5FC5;&amp;amp;#x987B;&amp;amp;#x4E3A;2&amp;amp;#x7684;&amp;amp;#x4E8C;&amp;amp;#x7EF4;&amp;amp;#x6570;&amp;amp;#x7EC4;&amp;amp;#x5FC5;&amp;amp;#x987B;&amp;amp;#x5BF9;&amp;amp;#x5E94;&amp;amp;#x7684;&amp;amp;#x4E0A;&amp;amp;#x4E0D;&amp;amp;#x7136;&amp;amp;#x5C31;&amp;amp;#x4F1A;&amp;amp;#x62A5;&amp;amp;#x9519;&#xD;print(a) 出来的结果：&#xA;同样你可以在输入数据的时候就把多少个存储下来然后用其他的函数去修改形状也行&#xA;利用empty来创建一个数组用来存储多个数据 利用empty来固定数组的维度&#xA;优点是比较简便&#xA;缺点是他好像他只可以用来固定1*n维的数组（有知道的评论区说一下）&#xA;import numpy as np&#xD;a=np.array([[1,2]],dtype=float)&#xD;b=np.array([[3,4]],dtype=float)&#xD;c=np.empty([0,2],dtype=float) #np.empty([x,y],dtype=float)&amp;amp;#x5E94;&amp;amp;#x8BE5;&amp;amp;#x6570;&amp;amp;#x521B;&amp;amp;#x5EFA;x&amp;amp;#x4E2A;&amp;amp;#x56FA;&amp;amp;#x5B9A;&amp;amp;#x4E3A;1*y&amp;amp;#x7C7B;&amp;amp;#x578B;&amp;amp;#x4E3A;float&amp;amp;#x7C7B;&amp;amp;#x578B;&amp;amp;#x7684;&amp;amp;#x6570;&amp;amp;#x7EC4;&#xD;c=np.append(c,a,axis=0)&#xD;c=np.append(c,b,axis=0)&#xD;print(c) 需要注意的是在empty中如果np.empty([x,y])x不为0的话新生成x个1*y维数组，值随机所以最好用0&#xA;之前不为0给我创建了x个1*y的随机值&#xA;结果：</description>
    </item>
    <item>
      <title>debian安装docker(通用方法）</title>
      <link>https://0ha.top/posts/130344753/</link>
      <pubDate>Fri, 19 May 2023 01:59:12 +0000</pubDate>
      <guid>https://0ha.top/posts/130344753/</guid>
      <description>本教程源于官网教程进行解释官网教程&#xA;docker容器是一个可以同时跑青龙（用于挂机脚本）与宝塔（用于便携式部署网站）之类的工具&#xA;我安装时在网络上搜索的教程来在部分电脑或者是主机上有时会出错尤其是32位系统的&#xA;于是我在疯狂百度总算找到一个我能用的方法&#xA;注意！！！不代表网络上其他的方法没用，我的另一台主机按照教程安装成功了，但是这台不行，如果其他的方法没用并且老是报错安装失败的话不妨试一试我的方法&#xA;首先要注意的是你的下载源有没有更换过&#xA;如果更换过的话我试过有些源是不行的&#xA;现在开始教程&#xA;首先就是老方法卸载旧版本docker&#xA;sudo apt-get remove docker docker-engine docker.io containerd runc 之后更新一下索引，再次提醒一下，如果国内源报错请换成官方源&#xA;sudo apt-get update 安装软件包以允许使用 基于 HTTPS 的存储库&#xA;sudo apt-get install \&#xD;ca-certificates \&#xD;curl \&#xD;gnupg 添加 Docker 的官方 GPG 密钥：&#xA;sudo install -m 0755 -d /etc/apt/keyrings&#xD;curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg&#xD;sudo chmod a+r /etc/apt/keyrings/docker.gpg 设置储存库&#xA;echo \&#xD;&amp;#34;deb [arch=&amp;#34;$(dpkg --print-architecture)&amp;#34; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \&#xD;&amp;#34;$(. /etc/os-release &amp;amp;&amp;amp; echo &amp;#34;$VERSION_CODENAME&amp;#34;)&amp;#34; stable&amp;#34; | \&#xD;sudo tee /etc/apt/sources.</description>
    </item>
    <item>
      <title>armbian的换源</title>
      <link>https://0ha.top/posts/130322147/</link>
      <pubDate>Fri, 19 May 2023 01:59:02 +0000</pubDate>
      <guid>https://0ha.top/posts/130322147/</guid>
      <description>安装好armbian和众多Linux一样，最重要的就是把原来的官方源给替换掉，换成国内的源，当然个人建议还是把官方的源备份一下以防出错。&#xA;cp /etc/apt/sources.list /etc/apt/sources.list.backage 打开源文件文本&#xA;nano /etc/apt/sources.list 这里是各个国内源。不用全复制，挑一个就行，我用的是163源（网易源）&#xA;163&amp;amp;#x955C;&amp;amp;#x50CF;&amp;amp;#x7AD9;&#xD;deb http://mirrors.163.com/debian/ buster main non-free contrib&#xD;deb http://mirrors.163.com/debian/ buster-updates main non-free contrib&#xD;deb http://mirrors.163.com/debian/ buster-backports main non-free contrib&#xD;deb http://mirrors.163.com/debian-security/ buster/updates main non-free contrib&#xD;deb-src http://mirrors.163.com/debian/ buster main non-free contrib&#xD;deb-src http://mirrors.163.com/debian/ buster-updates main non-free contrib&#xD;deb-src http://mirrors.163.com/debian/ buster-backports main non-free contrib&#xD;deb-src http://mirrors.163.com/debian-security/ buster/updates main non-free contrib&#xD;&amp;amp;#x534E;&amp;amp;#x4E3A;&amp;amp;#x4E91;&amp;amp;#x955C;&amp;amp;#x50CF;&amp;amp;#x7AD9;&#xD;deb https://mirrors.huaweicloud.com/debian/ buster main contrib non-free&#xD;deb https://mirrors.huaweicloud.com/debian/ buster-updates main contrib non-free&#xD;deb https://mirrors.</description>
    </item>
    <item>
      <title>anaconda导出离线包在新设备上安装python环境</title>
      <link>https://0ha.top/posts/130754033/</link>
      <pubDate>Thu, 18 May 2023 13:48:01 +0000</pubDate>
      <guid>https://0ha.top/posts/130754033/</guid>
      <description>前不久在学校做项目的时候用学校的电脑，但是学校的python环境需要配置，不巧的是学校网络不好而且每次开机都会重置电脑，所以我萌生出要做一个离线包拷贝到u盘里随插随用。&#xA;（虽然pycharm做项目可以保存环境，但是我导入到新版本的pycharm就失效了不知道是不是因为版本的问题）&#xA;正好我自己的电脑上有anaconda的环境我只要把他导入出来就行了&#xA;先进入搭建出来的环境(env_name为你搭建环境的名称 ）&#xA;activate env_name 然后导入配置的环境的列表&#xA;pip freeze &amp;gt; requirement.txt 最后&#xA;在你的u盘目录上输入cmd&#xA;输入&#xA;pip download -d ./libs -r requirement.txt 把文件保存在你新建的lib目录下&#xA;如果报错的换就换个源&#xA;pip download -d ./libs -r requirement.txt -i https://pypi.douban.com/simple 如果要在新电脑上加载你的安装源的话&#xA;就加入代码&#xA;pip isntall &amp;amp;#x5305;&amp;amp;#x540D; 或者把他粘贴到pycahrm的env目录下的Scripts也行&#xA;多谢这位大佬给我启发：&#xA;参考文章</description>
    </item>
    <item>
      <title>花生壳，nat123，srkura frp内网穿透对比（有主观成分</title>
      <link>https://0ha.top/posts/130376644/</link>
      <pubDate>Fri, 28 Apr 2023 04:01:42 +0000</pubDate>
      <guid>https://0ha.top/posts/130376644/</guid>
      <description>花生壳和nat123优缺点差不多一样，优点为部署简单不用再次申请域名，而且http协议是国内路线不用备案&#xA;缺点为要使用http协议要交钱，而且申请的是一个奇怪的二级域名并且不支持指定，要指定需要另外收费并且要付域名费用，带宽都为1m，花生壳每月1G，nat123不限流量&#xA;值得一提的是nat123的域名每个一段时间会强制变一下，比较不方便。&#xA;srkura frp我觉得总体比前两个要好&#xA;优点：免费10m的带宽，支持也只能用你自己单独申请的域名（可以二级域名也可一级域名），&#xA;限制流量但是每天签到送的流量几乎不可能用得完（平均每天2G）。&#xA;缺点：国内的http路线域名要备案，不管你是不是二级域名（二级域名不用也不能备案），但是可以走国外的线路，不过宽带速度和丢包率会有点高。</description>
    </item>
    <item>
      <title>路由器端口映射和dmz无法访问内网搭建的网站</title>
      <link>https://0ha.top/posts/130284390/</link>
      <pubDate>Fri, 21 Apr 2023 03:44:08 +0000</pubDate>
      <guid>https://0ha.top/posts/130284390/</guid>
      <description>昨天想着不用内网穿透用路由器端口映射打开或者路由器dmz做全端口映射&#xA;结果外网访问不了我宝塔搭建的网站&#xA;内网可以进（用的也是公网ip）&#xA;但是外网访问不了，后来我想是不是我的路由器是不是不是公网ip&#xA;结果百度搜索ip出现的ip和我路由器的wlan ip一样&#xA;嘶~不对啊，那为啥访问不了&#xA;然后我在手机开流量用我公网的ip用ssh链接了一下&#xA;成功了，证明确实做了端口映射&#xA;为什么访问不了我的网站&#xA;然后匪夷所思的是搭建宝塔网站外网可以访问&#xA;然后我找到一个链接测试端口（注意：依旧用外网或者流量访问）查看我开放的端口&#xA;结果发现&#xA;22506端口可以访问&#xA;80端口不能&#xA;结果显而易见&#xA;路由器把80端口封了，要开启就要去备案了（改成其他的端口外网应该也访问不了）&#xA;但是宝塔网站好像就能访问不知道为什么。有知道的可以解释一下。</description>
    </item>
    <item>
      <title>JAVA （1）</title>
      <link>https://0ha.top/posts/124517416/</link>
      <pubDate>Thu, 05 May 2022 09:37:44 +0000</pubDate>
      <guid>https://0ha.top/posts/124517416/</guid>
      <description>public class HelloWorld{ public static void main(String[] args){ System.out.println(&amp;#34;HelloWorld!&amp;#34;); } } </description>
    </item>
  </channel>
</rss>
